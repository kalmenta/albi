REGION OUC_BLOCK_CALLS
  //Only call if FB is processing
  IF #statStatus <> #STATUS_NO_CALL THEN
    // Connect and send
    IF #statConnParam.isQDN = TRUE THEN // Call if host is a domain name
      #instTsendC(REQ     := #statTsendcReq,
                  CONT    := #statTsendcEnable,
                  LEN     := #statTsendcLen,
                  DONE    => #tempTsendcDone,
                  BUSY    => #tempTsendcBusy,
                  ERROR   => #tempTsendcError,
                  STATUS  => #tempTsendcStatus,
                  CONNECT := #statConnParam.paramQDN,
                  DATA    := #statSendBuffer);
      
    ELSE
      #instTsendC(REQ     := #statTsendcReq,
                  CONT    := #statTsendcEnable,
                  LEN     := #statTsendcLen,
                  DONE    => #tempTsendcDone,
                  BUSY    => #tempTsendcBusy,
                  ERROR   => #tempTsendcError,
                  STATUS  => #tempTsendcStatus,
                  CONNECT := #statConnParam.paramIP,
                  DATA    := #statSendBuffer);
    END_IF;
    
    // Receive only when TCP operating
    #instTrcv(EN_R     := (#statFBState = #FB_STATE_OPERATING_MONITOR_TCP),
              ID       := #statConnParam.paramQDN.ConnPara.ID,
              ADHOC    := true,
              NDR      => #tempTrcvNdr,
              BUSY     => #tempTrcvBusy,
              ERROR    => #tempTrcvError,
              STATUS   => #tempTrcvStatus,
              RCVD_LEN => #tempTrcvRcvdLen,
              DATA     := #statRcvBuffer);
    
    //Monitor Time out
    #instTimerCommandWatchdog.TON(IN := #statEnableTimerCommandWatchdog,
                                  PT := #timeOut);
    //Mqtt Keepalive Timer
    #instMqttKeepAliveTimer.TON(IN := #statEnableMqttKeepAliveTimer,
                                PT := #statMqttKeepAliveTime);
  END_IF;
END_REGION

REGION ENABLING/DISABLING_FUNCTION_BLOCK
  IF (#tempEnable = TRUE) AND (#statStatus = #STATUS_NO_CALL) THEN // Enable FB
    // First call; initialize FB
    #statValid := TRUE;
    #statBusy := TRUE;
    #statError := FALSE;
    #statDone := FALSE;
    #statErrorUserCleared := FALSE;
    #statErrorAutoCleared := FALSE;
    #statStatus := #STATUS_FIRST_CALL;
    #statSubfunctionStatus := #STATUS_JOB_EXECUTED;
    #statFBErrorState := 0;
    #diagnostics := #statEmptyDiagnostics;
    #statDisablingCompleted := FALSE;
    // State machine - start functionality
    #statFBState := #FB_STATE_VALIDATE_INPUT;
    
    // Initialize functionality: reset of variables, diagnostics, etc.
    #statPublishOld := FALSE;
    #statSubscribeOld := FALSE;
    #statUnsubscribeOld := FALSE;
    #statConnParam.isQDN := FALSE;
    #statTsendcReq := FALSE;
    #statTsendcEnable := FALSE;
    #statTsendcLen := 0;
    #statEnableTimerCommandWatchdog := FALSE;
    #statEnableMqttKeepAliveTimer := FALSE;
    #statMqttKeepAliveTime := #KEEPALIVE_DISABLED;
    #statMqttKeepAliveUsed := FALSE;
    #statSendBufferPos := 0;
    #statPaketHeaderEncodeDone := FALSE;
    #statSendPaketTotalRemLen := 0;
    #statEncodedRemPaketLenAsByte := #EMPTY_BYTE;
    #statClientIdPos := 0;
    #statClientIdEncodeState := 0;
    #statClientIdLenUtf8Encoded := 0;
    #statUserNamePos := 0;
    #statUserNameEncodeState := #FIRST_ENCODING;
    #statUsernameLenUtf8Encoded := 0;
    #statPasswordPos := 0;
    #statPasswordEncodeState := #FIRST_ENCODING;
    #statPasswordLenUtf8Encoded := 0;
    #statWillQos := 0;
    #statWillRetain := FALSE;
    #statWillMessageCnt := 0;
    #statWillMessagePos := 0;
    #statWillMessageEncodeState := #FIRST_ENCODING;
    #statWillTopicLenUtf8Encoded := 0;
    #statWillTopicPos := 0;
    #statWillTopicEncodeState := #FIRST_ENCODING;
    #statPaketId := 0;
    #statPublishTopicLenUtf8Encoded := 0;
    #statPublishQos := 0;
    #statPublishMessageCnt := 0;
    #statPublishTopicEncodeState := #FIRST_ENCODING;
    #statPublishTopicPos := 0;
    #statPaketIdEncoded := FALSE;
    #statPublishEncodeMessageState := #FIRST_ENCODING;
    #statPublishMessagePos := 0;
    #statSubscribeQos := 0;
    #statSubscribeQosEncoded := FALSE;
    #statSubscribeTopicPos := 0;
    #statSubscribeTopicEncodeState := #FIRST_ENCODING;
    #statSubscribeTopicLenUtf8Encoded := 0;
    #statUnsubscribeTopicPos := 0;
    #statUnsubscribeTopicEncodeState := #FIRST_ENCODING;
    #statUnsubscribeTopicLenUtf8Encoded := 0;
    #statRcvMsgQoS := 0;
    #statRcvMsgTotalLen := 0;
    #statRcvMsgTopicLen := 0;
    #statRcvMsgPayloadLen := 0;
    #statRcvMsgPaketId := 0;
    #statRcvMsgTopicPos := 0;
    #statRcvMsgPayloadPos := 0;
    #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
    #statRcvMsgInternalStatus := 0;
    #statRcvMsgStatus := 0;
    #statRcvMsgDataLen := 0;
    #statSendPubAckMsg := FALSE;
    
    // Initialize functionality: call subsidiary FBs with FALSE
    FILL_BLK(IN    := #EMPTY_BYTE,
             COUNT := #MAX_BUFFER_LEN_SEND,
             OUT   => #statSendBuffer[0]);
    FILL_BLK(IN    := #EMPTY_BYTE,
             COUNT := #MAX_BUFFER_LEN_RCV,
             OUT   => #statRcvBuffer[0]);
    RESET_TIMER(#instTimerCommandWatchdog);
    RESET_TIMER(#instMqttKeepAliveTimer);
    
    // INIT SUB STATE MACHINES
    #statMqttConnectState := #MQTT_CONNECT_STATE_NO_PROCESSING;
    #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
    #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
    
  ELSIF (#tempEnable = FALSE) AND (#statEnableOld = TRUE) THEN // Disable FB 
    #statFBState := #FB_STATE_DISABLING;
  ELSIF (#statStatus = #STATUS_FIRST_CALL) THEN // Set status identifier of subsequent call
    #statStatus := #STATUS_SUBSEQUENT_CALL;
  END_IF;
  
  // Edge detection 'enable' input
  #statEnableOld := #tempEnable;
END_REGION ENABLING/DISABLING

IF (#statStatus = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce "system load"
  RETURN;
END_IF;

REGION STATE_MACHINE_FUNCTION_BLOCK_TCP
  CASE #statFBState OF // State machine of FB
    #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)
      ;
      
    #FB_STATE_VALIDATE_INPUT: // Enabling active
      REGION EVALUATE CONNECTION PARAMETERS
        // Broker address
        #tempBroker := #connParam.broker;
        // Determine if host is domain name or IP address
        #tempFirstChar := CHAR_TO_INT(#tempBroker[1]);
        
        IF #tempFirstChar >= CHAR_TO_INT('A') AND #tempFirstChar <= CHAR_TO_INT('z') THEN // Host is a domain name
          #statConnParam.isQDN := true;
        ELSIF #tempFirstChar >= CHAR_TO_INT('0') AND #tempFirstChar <= CHAR_TO_INT('9') THEN // Host is an IP address
          #statConnParam.isQDN := false;
        ELSE // URL invalid
          #statStatus := #ERR_BROKER_INVALID;
          #statFBErrorState := #statFBState;
          #statErrorUserCleared := TRUE;
        END_IF;
        
        IF #statConnParam.isQDN THEN // Broker address is a hostname
          IF #tempBroker[LEN(#tempBroker)] = '.' THEN
            #statConnParam.paramQDN.ConnPara.RemoteQDN := #tempBroker;
          ELSE
            #statConnParam.paramQDN.ConnPara.RemoteQDN := CONCAT(IN1 := #tempBroker, IN2 := '.');
          END_IF;
          #statConnParam.paramQDN.ConnPara.InterfaceId := #connParam.hwId;
          #statConnParam.paramQDN.ConnPara.ID := #connParam.connId;
          #statConnParam.paramQDN.ConnPara.ActiveEstablished := TRUE;
          #statConnParam.paramQDN.ConnPara.RemotePort := #connParam."port";
          
        ELSE // Broker address is an IP address
          FOR #tempLoopCounter := 1 TO 3 DO
            #tempFirstChar := FIND(IN1 := #tempBroker, IN2 := '.');
            #statConnParam.paramIP.ConnPara.RemoteAddress.ADDR[#tempLoopCounter] := UINT_TO_BYTE(STRING_TO_UINT(LEFT(IN := #tempBroker, L := #tempFirstChar - 1)));
            #tempBroker := DELETE(IN := #tempBroker, L := #tempFirstChar, P := 1);
          END_FOR;
          #statConnParam.paramIP.ConnPara.RemoteAddress.ADDR[4] := UINT_TO_BYTE(STRING_TO_UINT(#tempBroker));
          #statConnParam.paramIP.ConnPara.InterfaceId := #connParam.hwId;
          #statConnParam.paramIP.ConnPara.ID:= #statConnParam.paramQDN.ConnPara.ID:=#connParam.connId;
          #statConnParam.paramIP.ConnPara.ActiveEstablished := TRUE;
          #statConnParam.paramIP.ConnPara.RemotePort := #connParam."port";
        END_IF;
        
        IF #connParam.tls.enableTls THEN
          IF #statConnParam.isQDN THEN
            #statConnParam.paramQDN.ActivateSecureConn := TRUE;
            #statConnParam.paramQDN.ExtTLSCapabilities.%X0 := #connParam.tls.validateServerIdentity;
            #statConnParam.paramQDN.TLSServerCertRef := #connParam.tls.brokerCert;
            #statConnParam.paramQDN.TLSClientCertRef := #connParam.tls.clientCert;
          ELSE
            #statConnParam.paramIP.ActivateSecureConn := TRUE;
            #statConnParam.paramIP.ExtTLSCapabilities.%X0 := #connParam.tls.validateServerIdentity;
            #statConnParam.paramIP.TLSServerCertRef := #connParam.tls.brokerCert;
            #statConnParam.paramIP.TLSClientCertRef := #connParam.tls.clientCert;
          END_IF;
        END_IF;
      END_REGION EVALUATE CONNECTION PARAMETERS
      
      REGION FB_VALIDATE_INPUT     
        //Check Input variables:
        #tempMaxWillMsgLen := ABS(UPPER_BOUND(ARR := #willMsgPayload, DIM := #ONE_DIMENSION) - LOWER_BOUND(ARR := #willMsgPayload, DIM := #ONE_DIMENSION)) + #ARRAY_LEN_OFFSET_PLUS_1;
        
        //Check Client ID len Must be > 0 
        IF LEN(#clientIdentifier) <= #LEN_NULL THEN
          #statStatus := #ERR_CLIENT_ID_NULL; // Set correct status that identifies error clearly
          #statSubfunctionStatus := #ERR_CLIENT_ID_NULL; // Status or return value of called FBs, FCs and system blocks
          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
          #statErrorUserCleared := TRUE;
          //verify Will next
        ELSIF #tempMaxWillMsgLen < #willMsgLen THEN
          #statStatus := #ERR_CNT_EXCEEDS_ARRAY_DIMENSION; // Set correct status that identifies error clearly
          #statSubfunctionStatus := #ERR_CNT_EXCEEDS_ARRAY_DIMENSION; // Status or return value of called FBs, FCs and system blocks
          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
          #statErrorUserCleared := TRUE;
          ///CHECK WILL QOS
        ELSIF #qos > #MQTT_QOS_2 THEN
          #statStatus := #ERR_QOS_INVALID; // Set correct status that identifies error clearly
          #statSubfunctionStatus := #ERR_QOS_INVALID; // Status or return value of called FBs, FCs and system blocks
          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
          #statErrorUserCleared := TRUE;
        ELSIF (#connParam.keepAlive < #THREE_SECONDS) // IF Set to 1 or 2 seconds..
          AND (#connParam.keepAlive > 0)
        THEN
          #statStatus := #ERR_KEEPALIVE_INVALID; // Set correct status that identifies error clearly
          #statSubfunctionStatus := #ERR_KEEPALIVE_INVALID; // Status or return value of called FBs, FCs and system blocks
          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
          #statErrorUserCleared := TRUE;
        ELSE
          //Set Params for connection
          //Set Client Id
          #statWillQos := #qos;
          //set Retain
          #statWillRetain := #retain;
          // Will message cnt
          #statWillMessageCnt := #willMsgLen;
          
          //Keepalive
          IF #connParam.keepAlive = 0 THEN
            #statMqttKeepAliveUsed := FALSE;
          ELSE
            #statMqttKeepAliveUsed := TRUE;
            //KeepAliveTImer is set to ((Keep Alive converted to seconds) - 2s)
            #statMqttKeepAliveTime := UINT_TO_TIME((#connParam.keepAlive * #UINT_CONST_1000 - #TWO_SECONDS));
          END_IF;
          
          //rdy to enable TCON
          #statTsendcEnable := TRUE;
          #statEnableTimerCommandWatchdog := TRUE;
          #statFBState := #FB_STATE_TCP_CONNECTING;
        END_IF;
      END_REGION FB_VALIDATE_INPUT
      
    #FB_STATE_TCP_CONNECTING: //Wait for TCP to be established
      REGION FB_TCP_CONNECTING
        //Check process:
        IF #tempTsendcError = TRUE THEN //when error:
          #statTsendcEnable := FALSE; //disable TsendC
          #statEnableTimerCommandWatchdog := FALSE;
          #statStatus := #ERR_TCON_FAILED; // Set correct status that identifies error clearly
          #statSubfunctionStatus := #tempTsendcStatus; // Status or return value of called FBs, FCs and system blocks
          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
          #statErrorUserCleared := TRUE;
        ELSIF #tempTsendcStatus = #TSENDC_EST_OK THEN //when successfull:
          //     Communication connection established.
          #statEnableTimerCommandWatchdog := FALSE;
          //Monitor Connection
          #statFBState := #FB_STATE_OPERATING_MONITOR_TCP;
          // Begin MQTT Connection
          #statMqttConnectState := #MQTT_CONNECT_STATE_BUILD_PAKET;
          //set status
          #statStatus := #STATUS_MQTT_CONNECTING;
        ELSIF #instTimerCommandWatchdog.Q THEN
          #statTsendcEnable := FALSE; //disable TsendC
          #statEnableTimerCommandWatchdog := FALSE;
          #statStatus := #ERR_TCON_TIMEOUT; // Set correct status that identifies error clearly
          #statSubfunctionStatus := #ERR_TCON_TIMEOUT; // Status or return value of called FBs, FCs and system blocks
          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
          #statErrorUserCleared := TRUE;
        END_IF;
      END_REGION FB_TCP_CONNECTING
    #FB_STATE_OPERATING_MONITOR_TCP: // Processing active
      REGION FB_OPERATING_MONITOR_TCP
        //Reset Status on Msg Output - will be set when a new message is completly processed and ready at outputs.
        #statRcvMsgStatus := #MSG_DECODE_STATUS_NO_NEW_MSG;
        //Reset TsendC Req from last  cycle Request:
       
        #statTsendcReq := FALSE;
       
        //Monitor Connection - if disconnect occured:
        IF ((#tempTsendcStatus > #TSENDC_COM_CLOSED AND #tempTsendcStatus < #TSENDC_EST_OK) //Status connection interupt
          OR #tempTsendcError = TRUE) // Or error
          AND #tempTrcvNdr = FALSE // And no new data (to see if broker send information why connection was interrupted)
        THEN
          REGION CONNECTION_INTERRUPTED
            //Status reconnecting
            //SET MQTT to no operation
            #statMqttConnectState := #MQTT_CONNECT_STATE_NO_PROCESSING;
            #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
            #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
            //Reset Pub ack
            #statSendPubAckMsg := FALSE;
            //reset Done bit if still set, regardless of input:
            #statDone := FALSE;
            //reset Watchdog
            #statEnableTimerCommandWatchdog := FALSE;
            // reset headerEncode
            #statPaketHeaderEncodeDone := FALSE;
            //set error  information
            #statStatus := #ERR_TCP_RECONNECTING; // Set correct status that identifies error clearly
            #statSubfunctionStatus := #tempTsendcStatus;// Status or return value of called FBs, FCs and system blocks
            #statFBErrorState := #statFBState; // Set error state number for diagnostic 
            #statErrorAutoCleared := TRUE;
            //Wait for reconect - next state
            #statFBState := #FB_STATE_TCP_RECONNECTING;
          END_REGION REGION CONNECTION_INTERRUPTED
        ELSE
          //Connection is OK
          //Sending and receiving works 
          //Check Trcv Buffer for new Data
          IF #tempTrcvNdr THEN
            REGION TRCV_NEW_DATA
              //Evaluate the TrcvBuffer, reset buffer pos to start
              #tempTrcvBufferPos := 0;
              // Parse the whole RCV Buffer
              WHILE #tempTrcvBufferPos < (UDINT_TO_DINT(#tempTrcvRcvdLen)) DO
                // Parse the whole RCV Buffer, check wether header or decoding
                IF #statRcvMsgDecodeState = #MSG_DECODE_STATE_NO_PROCESSING THEN
                  //If no decoding is in progress, look for new message header
                  #tempRcvMsgTypeCase := #statRcvBuffer[#tempTrcvBufferPos] AND #BIT_MASK_HIGHBITS;
                ELSE
                  //decode is in progress, go directly to decoding
                  #tempRcvMsgTypeCase := #MQTT_MSG_DECODING;
                END_IF;
                
                CASE #tempRcvMsgTypeCase OF
                  #MQTT_MSG_TYPE_CONNACK:  // Statement section case 1
                    REGION RECEIVED_CONACK_PACKET    
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINING_LEN_2 //remainng Length must be 2;
                      THEN //
                        #tempTrcvBufferPos += 1;
                        //byte one is 0000 000X where X is if Session was set // so depending on clean session or not  evaluate answer of server
                        IF #statRcvBuffer[#tempTrcvBufferPos] = #MQTT_NO_SESSION_PRESENT THEN
                          #tempTrcvBufferPos += 1;
                          //VALID Answer, check code
                          IF #statRcvBuffer[#tempTrcvBufferPos] = #MQTT_CONNACK_ACCEPTED
                          THEN
                            //All good
                            #tempTrcvBufferPos += 1;
                            #tempMqttConnAckRcvStatus := #RESPONSE_GOOD; //evaluate in MQTT StateMachine Below the response
                          ELSE
                            //NOT VALID CONNACK from server shows session has a bad return code
                            #statStatus := #ERR_MQTT_CONNACK_RETURN_CODE_INVALID; // Set correct status that identifies error clearly
                            #statSubfunctionStatus := #statRcvBuffer[#tempTrcvBufferPos]; // Status or return value of called FBs, FCs and system blocks
                            #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                            #statErrorUserCleared := TRUE;
                            // Exit loop
                            EXIT;
                          END_IF;
                        ELSE
                          //NOT VALID, CONNACK from server shows session present
                          #statStatus := #ERR_MQTT_CONNACK_INVALID_SESSION_FLAG; // Set correct status that identifies error clearly
                          #statSubfunctionStatus := #ERR_MQTT_CONNACK_INVALID_SESSION_FLAG; // Status or return value of called FBs, FCs and system blocks
                          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                          #statErrorUserCleared := TRUE;
                          // Exit loop
                          EXIT;
                        END_IF;
                      ELSE // We got a CONNACK paket, but remaining length was not 2 (Error)
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_CONACK_PACKET 
                    
                  #MQTT_MSG_TYPE_PINGRESP:
                    REGION RECEIVED_PINGRESP_PACKET
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINIG_LEN_0 //remainng Length must be 0;
                      THEN
                        #tempTrcvBufferPos += 1;
                        #tempMqttPingRspRcv := #RESPONSE_GOOD; //evaluate in MQTT StateMachine Below the response
                      ELSE// We got a Pingrsp paket, but remaining length was not 0 (Error)
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_PINGRESP_PAKET
                    
                  #MQTT_MSG_TYPE_PUBACK:
                    REGION RECEIVED_PUBACK_PAKET
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINING_LEN_2 //remainng Length must be 2;
                      THEN //
                        #tempTrcvBufferPos += 1;
                        #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                        IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B1 THEN
                          #tempTrcvBufferPos += 1;
                          IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B0 THEN
                            #tempTrcvBufferPos += 1;
                            #tempMqttPubAckRcv := #RESPONSE_GOOD;
                          ELSE
                            #tempTrcvBufferPos += 1;
                            #tempMqttPubAckRcv := #RESPONSE_PAKET_ID_INVALID;
                          END_IF;
                        ELSE
                          #tempTrcvBufferPos += 1;
                          #tempMqttPubAckRcv := #RESPONSE_PAKET_ID_INVALID;
                        END_IF;
                      ELSE
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_PUBACK_PAKET
                    
                  #MQTT_MSG_TYPE_PUBREC:
                    REGION RECEIVED_PUBREC_PAKET
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINING_LEN_2 //remainng Length must be 2;
                      THEN //
                        #tempTrcvBufferPos += 1;
                        #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                        IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B1 THEN
                          #tempTrcvBufferPos += 1;
                          IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B0 THEN
                            #tempTrcvBufferPos += 1;
                            #statMqttPubRecRcv := #RESPONSE_GOOD;
                          ELSE
                            #tempTrcvBufferPos += 1;
                            #statMqttPubRecRcv := #RESPONSE_PAKET_ID_INVALID;
                          END_IF;
                        ELSE
                          #tempTrcvBufferPos += 1;
                          #statMqttPubRecRcv := #RESPONSE_PAKET_ID_INVALID;
                        END_IF;
                      ELSE
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_PUBREC_PAKET
                    
                  #MQTT_MSG_TYPE_PUBCOMP:
                    REGION RECEIVED_PUBCOMP_PAKET
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINING_LEN_2 //remainng Length must be 2;
                      THEN //
                        #tempTrcvBufferPos += 1;
                        #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                        IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B1 THEN
                          #tempTrcvBufferPos += 1;
                          IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B0 THEN
                            #tempTrcvBufferPos += 1;
                            #tempMqttPubCompRcv := #RESPONSE_GOOD;
                            
                          ELSE
                            #tempTrcvBufferPos += 1;
                            #tempMqttPubCompRcv := #RESPONSE_PAKET_ID_INVALID;
                            
                          END_IF;
                        ELSE
                          #tempTrcvBufferPos += 1;
                          #tempMqttPubCompRcv := #RESPONSE_PAKET_ID_INVALID;
                          
                        END_IF;
                      ELSE
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_PUBCOMP_PAKET
                    
                  #MQTT_MSG_TYPE_SUBACK:
                    REGION RECEIVED_SUBACK_PAKET
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINING_LEN_3 //remainng Length must be 3;
                      THEN //
                        #tempTrcvBufferPos += 1;
                        #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                        IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B1 THEN
                          #tempTrcvBufferPos += 1;
                          IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B0 THEN
                            #tempTrcvBufferPos += 1;
                            IF #statRcvBuffer[#tempTrcvBufferPos] = #SUBSCRIBE_FAILURE THEN
                              #tempTrcvBufferPos += 1;
                              #tempMqttSubAckRcv := #RESPONSE_SUBSCRIBE_FAILED;
                            ELSE
                              #tempTrcvBufferPos += 1;
                              #tempMqttSubAckRcv := #RESPONSE_GOOD;
                            END_IF;
                          ELSE
                            #tempTrcvBufferPos += 1;
                            #tempMqttSubAckRcv := #RESPONSE_PAKET_ID_INVALID;
                          END_IF;
                        ELSE
                          #tempTrcvBufferPos += 1;
                          #tempMqttSubAckRcv := #RESPONSE_PAKET_ID_INVALID;
                        END_IF;
                      ELSE
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_SUBACK_PAKET
                    
                  #MQTT_MSG_TYPE_UNSUBACK:
                    REGION RECEIVED_UNSUBACK_PAKET
                      #tempTrcvBufferPos += 1;
                      IF #statRcvBuffer[#tempTrcvBufferPos] = #REMAINING_LEN_2 //remainng Length must be 2;
                      THEN //
                        #tempTrcvBufferPos += 1;
                        #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                        IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B1 THEN
                          #tempTrcvBufferPos += 1;
                          IF #statRcvBuffer[#tempTrcvBufferPos] = #tempWordForSliceAddress.%B0 THEN
                            #tempTrcvBufferPos += 1;
                            #tempMqttUnSubAckRcv := #RESPONSE_GOOD;
                          ELSE
                            #tempTrcvBufferPos += 1;
                            #tempMqttUnSubAckRcv := #RESPONSE_PAKET_ID_INVALID;
                          END_IF;
                        ELSE
                          #tempTrcvBufferPos += 1;
                          #tempMqttUnSubAckRcv := #RESPONSE_PAKET_ID_INVALID;
                        END_IF;
                      ELSE
                        #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                    END_REGION RECEIVED_UNSUBACK_PAKET
                    
                  #MQTT_MSG_TYPE_RCV_PUB_MESSAGE:
                    REGION RECEIVED_PUBLISH_PAKET_FROM_BROKER
                      //Received a message, start process.
                      //init
                      #tempMultiplierToDecode := #INIT_UDINT_1;
                      #statRcvMsgInternalStatus := #MSG_DECODE_STATUS_NO_NEW_MSG;
                      #statRcvMsgTotalLen := 0;
                      #statRcvMsgTopicLen := 0;
                      #statRcvMsgPayloadLen := 0;
                      //Check and store QoS for later use
                      IF (#statRcvBuffer[#tempTrcvBufferPos] AND #BIT_MASK_QOS) = #MQTT_MSG_TYPE_RCV_PUB_MESSAGE_QoS0
                      THEN
                        #statRcvMsgQoS := #MQTT_QOS_0;
                      ELSIF (#statRcvBuffer[#tempTrcvBufferPos] AND #BIT_MASK_QOS) = #MQTT_MSG_TYPE_RCV_PUB_MESSAGE_QoS1
                      THEN
                        #statRcvMsgQoS := #MQTT_QOS_1;
                      ELSIF (#statRcvBuffer[#tempTrcvBufferPos] AND #BIT_MASK_QOS) = #MQTT_MSG_TYPE_RCV_PUB_MESSAGE_QoS2
                      THEN
                        #statRcvMsgQoS := #MQTT_QOS_2;
                      ELSIF (#statRcvBuffer[#tempTrcvBufferPos] AND #BIT_MASK_QOS) = #MQTT_MSG_TYPE_RCV_PUB_MESSAGE_BAD
                      THEN
                        #statStatus := #ERR_MQTT_MALFORMED_QOS_RECEIVED; // Set correct status that identifies error clearly
                        #statSubfunctionStatus := #ERR_MQTT_MALFORMED_QOS_RECEIVED; // Status or return value of called FBs, FCs and system blocks
                        #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                        #statErrorUserCleared := TRUE;
                        // Exit loop
                        EXIT;
                      END_IF;
                      
                      //Calculate total publish len (topic,paketid,payload)
                      REPEAT
                        #tempTrcvBufferPos += 1; //Increment
                        #statRcvMsgTotalLen += BYTE_TO_UDINT((#statRcvBuffer[#tempTrcvBufferPos] AND #DEFAULT_MULTIPLIER_BYTE_127)) * #tempMultiplierToDecode;
                        #tempMultiplierToDecode *= #SEND_LEN_MULTIPLIER_UDINT_128;
                        IF (#tempMultiplierToDecode > #MAX_ALLOWED_PAKET_SIZE)
                        THEN//Throw error here // Malformed remain length.
                          #statStatus := #ERR_MQTT_REM_LEN_INVALID; // Set correct status that identifies error clearly
                          #statSubfunctionStatus := #ERR_MQTT_REM_LEN_INVALID; // Status or return value of called FBs, FCs and system blocks
                          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                          #statErrorUserCleared := TRUE;
                          // Exit loop
                          EXIT;
                        END_IF;
                      UNTIL ((#statRcvBuffer[#tempTrcvBufferPos] AND UDINT_TO_BYTE(#SEND_LEN_MULTIPLIER_UDINT_128)) = 0)
                      END_REPEAT;
                      #tempTrcvBufferPos += 1; //Increment
                      //#statIncPaketRemLen contains total paket len
                      //Save Topic Len
                      #tempWordForSliceAddress.%B1 := #statRcvBuffer[#tempTrcvBufferPos]; //MSB
                      #tempTrcvBufferPos += 1; //Increment
                      #tempWordForSliceAddress.%B0 := #statRcvBuffer[#tempTrcvBufferPos]; //LSB
                      #tempTrcvBufferPos += 1; //Increment
                      #statRcvMsgTopicLen := WORD_TO_UINT(#tempWordForSliceAddress);
                      //Set Payload len
                      IF #statRcvMsgQoS = #MQTT_QOS_0 THEN
                        //Payload Len is total Len minus topic len minus topic len info 
                        #statRcvMsgPayloadLen := #statRcvMsgTotalLen - #statRcvMsgTopicLen - #TWO_BYTE_LEN_INFO;
                      ELSE
                        //PayloadLen is total Len minus topic len minus topic len info minus paket Id len
                        #statRcvMsgPayloadLen := #statRcvMsgTotalLen - #statRcvMsgTopicLen - #TWO_BYTE_LEN_INFO - #TWO_BYTE_LEN_INFO;
                      END_IF;
                      
                      //Clear Output message:
                      #receivedTopic := #EMPTY_WSTRING;
                      //Start receiving with topic
                      #statRcvMsgDecodeState := #MSG_DECODE_STATE_TOPIC;
                      //Start Topic at first character
                      #statRcvMsgTopicPos := #FIRST_CHARACTER;
                      //Start RcvMsg at first array element
                      #statRcvMsgPayloadPos := LOWER_BOUND(ARR := #receivedMsgPayload, DIM := #ONE_DIMENSION);
                      //Set Output for received len according to array dimension
                      #tempReceivedMsgDataArrayTotalLen := ABS(UPPER_BOUND(ARR := #receivedMsgPayload, DIM := #ONE_DIMENSION) - LOWER_BOUND(ARR := #receivedMsgPayload, DIM := #ONE_DIMENSION)) + #ARRAY_LEN_OFFSET_PLUS_1;
                      IF #statRcvMsgPayloadLen < #tempReceivedMsgDataArrayTotalLen THEN
                        #statRcvMsgDataLen := #statRcvMsgPayloadLen;
                      ELSE
                        #statRcvMsgDataLen := DINT_TO_UDINT(#tempReceivedMsgDataArrayTotalLen);
                      END_IF;
                    END_REGION RECEIVED_PUBLISH_PAKET_FROM_BROKER
                    
                  #MQTT_MSG_DECODING:
                    REGION RECEIVED_PAKET_DECODE
                      CASE #statRcvMsgDecodeState OF
                        #MSG_DECODE_STATE_NO_PROCESSING: // NO Processing
                          ;
                        #MSG_DECODE_STATE_TOPIC:  // Statement section case 1
                          #tempReceivedTopicStringMaxLen := MAX_LEN(#receivedTopic);
                          //Copy Topic To WString Inout
                          IF #statRcvMsgTopicPos <= #tempReceivedTopicStringMaxLen THEN
                            #receivedTopic[#statRcvMsgTopicPos] := BYTE_TO_WCHAR(#statRcvBuffer[#tempTrcvBufferPos]);
                            #statRcvMsgTopicPos += 1;
                          ELSE
                            //Max String len reached.
                            #statRcvMsgInternalStatus := #MSG_DECODE_STATUS_TOPIC_TOO_LONG;
                          END_IF;
                          //decrement
                          #statRcvMsgTopicLen -= 1;
                          //increment
                          #tempTrcvBufferPos += 1;
                          //Check condition, if topic fully decoded:
                          IF #statRcvMsgTopicLen <= 0 THEN
                            //Decide what to do next:
                            IF #statRcvMsgQoS > #MQTT_QOS_0 THEN
                              //NextStep Decode PaketID
                              #statRcvMsgDecodeState := #MSG_DECODE_STATE_PAKET_ID_MSB;
                            ELSIF #statRcvMsgQoS = #MQTT_QOS_0 AND #statRcvMsgPayloadLen > 0 THEN
                              //NextStep Decode Payload
                              #statRcvMsgDecodeState := #MSG_DECODE_STATE_PAYLOAD;
                            ELSE
                              // QoS=0 and no Payload => Done
                              // Decoding complete
                              #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
                              //Set New message flag
                              IF #statRcvMsgInternalStatus = #MSG_DECODE_STATUS_NO_NEW_MSG THEN
                                //New message received ok
                                #statRcvMsgStatus := #MSG_DECODE_STATUS_NEW_MSG_OK;
                              ELSE
                                //Message received, but Payload or Topic longer than inout data area
                                #statRcvMsgStatus := #MSG_DECODE_STATUS_TOPIC_TOO_LONG;
                              END_IF;
                            END_IF;
                          END_IF;
                        #MSG_DECODE_STATE_PAKET_ID_MSB:  // Decode PaketId MSB
                          //Copy PaketID
                          #statRcvMsgPaketId.%B1 := #statRcvBuffer[#tempTrcvBufferPos]; //MSB
                          #tempTrcvBufferPos += 1; //Increment
                          #statRcvMsgDecodeState := #MSG_DECODE_STATE_PAKET_ID_LSB;
                        #MSG_DECODE_STATE_PAKET_ID_LSB: // Decode PaketId LSB
                          //Copy PaketID
                          #statRcvMsgPaketId.%B0 := #statRcvBuffer[#tempTrcvBufferPos]; //LSB
                          #tempTrcvBufferPos += 1; //Increment
                          IF #statRcvMsgPayloadLen > 0 THEN
                            #statRcvMsgDecodeState := #MSG_DECODE_STATE_PAYLOAD;
                          ELSE
                            // Decoding complete
                            #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
                            //Set New message flag
                            IF #statRcvMsgInternalStatus = #MSG_DECODE_STATUS_NO_NEW_MSG THEN
                              //New message received ok
                              #statRcvMsgStatus := #MSG_DECODE_STATUS_NEW_MSG_OK;
                            ELSE
                              //Message received, but Payload or Topic longer than inout data area
                              #statRcvMsgStatus := #MSG_DECODE_STATUS_TOPIC_TOO_LONG;
                            END_IF;
                            // Send PubAck Msg
                            #statSendPubAckMsg := TRUE;
                          END_IF;
                        #MSG_DECODE_STATE_PAYLOAD:
                          #tempUpperBoundRcvMsgDataArray := UPPER_BOUND(ARR := #receivedMsgPayload, DIM := #ONE_DIMENSION);
                          
                          IF #statRcvMsgPayloadPos <= #tempUpperBoundRcvMsgDataArray THEN
                            //Copy to output
                            #receivedMsgPayload[#statRcvMsgPayloadPos] := (#statRcvBuffer[#tempTrcvBufferPos]);
                            //Increment the pos
                            #statRcvMsgPayloadPos += 1;
                          ELSE
                            //Max Payload len reached, skip
                            #statRcvMsgInternalStatus := #MSG_DECODE_STATUS_PAYLOAD_TOO_LONG;
                          END_IF;
                          //Decrement msg payload len
                          #statRcvMsgPayloadLen -= 1;
                          //Increment Buffer Pos
                          #tempTrcvBufferPos += 1;
                          //Check condition, if payload fully decoded:
                          IF #statRcvMsgPayloadLen <= 0 THEN
                            // Decoding complete
                            #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
                            //Set New message flag
                            IF #statRcvMsgInternalStatus = #MSG_DECODE_STATUS_NO_NEW_MSG THEN
                              //New message received ok
                              #statRcvMsgStatus := #MSG_DECODE_STATUS_NEW_MSG_OK;
                            ELSE
                              //Message received, but Payload or Topic longer than inout data area
                              #statRcvMsgStatus := #MSG_DECODE_STATUS_PAYLOAD_TOO_LONG;
                            END_IF;
                            //Decide if a PUB ACK needs to be send
                            IF #statRcvMsgQoS > #MQTT_QOS_0 THEN
                              // Send PubAck Msg
                              #statSendPubAckMsg := TRUE;
                            END_IF;
                          END_IF;
                        ELSE
                          //else case
                          #statStatus := #ERR_UNDEFINED_STATE;
                          #statErrorUserCleared := TRUE;
                          ;
                      END_CASE;
                    END_REGION RECEIVED_PAKET_DECODE
                  ELSE // No Header found, SKIP entry of buffer:
                    #tempTrcvBufferPos += 1;
                END_CASE;
              END_WHILE;
            END_REGION TRCV_NEW_DATA
          END_IF;
          
          //Send an Publish Acknowledge Msg, if necessary
          REGION SEND_PUB_ACK_MSG_ON_SUBSCRIPTIONS
            //Send Acknowledgements to Subscribed messages, if requested (QoS =1)
            IF #statSendPubAckMsg = TRUE AND // send pub ack Request
              #statMqttCommandState = #MQTT_COMMAND_STATE_NO_PROCESSING AND // no send job processing
              #tempTsendcBusy = FALSE AND // tsendC is ready
              #tempTsendcDone = FALSE // tsendC did not finished in this cycle
            THEN
              //Set Pos
              #statSendBufferPos := 0;
              //Write Msg Type
              #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_PUBACK;
              #statSendBufferPos += 1;
              //Write Msg Len
              #statSendBuffer[#statSendBufferPos] := #REMAINING_LEN_2;
              #statSendBufferPos += 1;
              //Write Paket Id - first MSB then LSB
              #statSendBuffer[#statSendBufferPos] := #statRcvMsgPaketId.%B1;
              #statSendBufferPos += 1;
              #statSendBuffer[#statSendBufferPos] := #statRcvMsgPaketId.%B0;
              #statSendBufferPos += 1;
              //Set Send Len:
              #statTsendcLen := #statSendBufferPos;
              //Send msg
              #statTsendcReq := TRUE;
              //Reset ack:
              #statSendPubAckMsg := FALSE;
            END_IF;
          END_REGION SEND_PUB_ACK_MSG_ON_SUBSCRIPTIONS
          
          REGION MQTT_STATE_MACHINE
            CASE #statMqttConnectState OF
              #MQTT_CONNECT_STATE_NO_PROCESSING:  // Statement section case 1
                ;
              #MQTT_CONNECT_STATE_BUILD_PAKET:  //
                REGION BUILD_CONNECT_PAKET
                  //Remaining Length is the length of the variable header (10 bytes) plus the length of the Payload. 
                  //Max Len of Mqtt pakets is per Standard 268,435,455 Bytes (ff,ff,ff,7f)
                  //Calculate Remain Len will be 10 bytes
                  //plus Len of ClientId   (max 3*16382 WChars= 49.146 Bytes)
                  //plus Len of User (max 3*16382 WChars= 49.146 Bytes)
                  //plus Len of PW (max 3*16382 WChars= 49.146 Bytes)
                  //plus Len of WillTopic (max 3*16382 WChars= 49.146 Bytes)
                  //plus Len of WillMessage (max 65535 Bytes - as only 2 Bytes Len info is possible)
                  // = Total 262 119 Bytes
                  
                  
                  // Must obey, if not currently sending PubAck Msg on a subscription
                  // Else, try in the next cycle
                  IF #tempTsendcBusy = FALSE AND // tsendC is ready
                    #tempTsendcDone = FALSE AND  // tsendC did not finish in this cycle
                    #statTsendcReq = FALSE THEN // no request from pub ack request
                    
                    //Only need to encode header once
                    IF #statPaketHeaderEncodeDone = FALSE THEN
                      // INIT
                      #statSendBufferPos := 0;
                      #statClientIdPos := #FIRST_CHARACTER;
                      #statClientIdEncodeState := #FIRST_ENCODING;
                      
                      #statWillTopicEncodeState := #FIRST_ENCODING;
                      #statWillTopicPos := #FIRST_CHARACTER;
                      
                      #statWillMessageEncodeState := #FIRST_ENCODING;
                      #statWillMessagePos := 0; // The Posistion for the WILL Message Array
                      
                      #statUserNameEncodeState := #FIRST_ENCODING;
                      #statUserNamePos := #FIRST_CHARACTER;
                      
                      #statPasswordEncodeState := #FIRST_ENCODING;
                      #statPasswordPos := #FIRST_CHARACTER;
                      
                      #statSendPaketTotalRemLen := #CONNECT_HEADER_10BYTE_LEN;
                      #statClientIdLenUtf8Encoded := 0;
                      #statWillTopicLenUtf8Encoded := 0;
                      #statUsernameLenUtf8Encoded := 0;
                      #statPasswordLenUtf8Encoded := 0;
                      //End Init
                      
                      // Encode Client ID Len
                      // Client ID must always be present
                      FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#clientIdentifier) DO
                        "LMQTT_ConvertToUtf8"(character     := #clientIdentifier[#tempLoopCounter],
                                              convertedUtf8 => #tempConvertedUtf8,
                                              bytesUsed     => #tempBytesUsedUtf8,
                                              error         => #tempErrorConvertUtf8,
                                              status        => #tempStatusConvertUtf8);
                        #statClientIdLenUtf8Encoded := #statClientIdLenUtf8Encoded + #tempBytesUsedUtf8;
                      END_FOR;
                      
                      #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statClientIdLenUtf8Encoded + #TWO_BYTE_LEN_INFO;
                      
                      
                      IF #username <> #EMPTY_WSTRING
                      THEN
                        #tempUserFlag := TRUE;
                        FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#username) DO
                          "LMQTT_ConvertToUtf8"(character     := #username[#tempLoopCounter],
                                                convertedUtf8 => #tempConvertedUtf8,
                                                bytesUsed     => #tempBytesUsedUtf8,
                                                error         => #tempErrorConvertUtf8,
                                                status        => #tempStatusConvertUtf8);
                          #statUsernameLenUtf8Encoded := #statUsernameLenUtf8Encoded + #tempBytesUsedUtf8;
                        END_FOR;
                        #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statUsernameLenUtf8Encoded + #TWO_BYTE_LEN_INFO;
                      ELSE
                        #statUserNameEncodeState := #NOT_USED_NO_ENCODING;
                        #tempUserFlag := FALSE;
                      END_IF;
                      
                      IF #password <> #EMPTY_WSTRING AND #username <> #EMPTY_WSTRING
                      THEN
                        #tempPasswordFlag := TRUE;
                        FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#password) DO
                          "LMQTT_ConvertToUtf8"(character     := #password[#tempLoopCounter],
                                                convertedUtf8 => #tempConvertedUtf8,
                                                bytesUsed     => #tempBytesUsedUtf8,
                                                error         => #tempErrorConvertUtf8,
                                                status        => #tempStatusConvertUtf8);
                          #statPasswordLenUtf8Encoded := #statPasswordLenUtf8Encoded + #tempBytesUsedUtf8;
                        END_FOR;
                        #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statPasswordLenUtf8Encoded + #TWO_BYTE_LEN_INFO;
                      ELSE
                        #statPasswordEncodeState := #NOT_USED_NO_ENCODING;
                        #tempPasswordFlag := FALSE;
                      END_IF;
                      
                      
                      IF #willtopic <> #EMPTY_WSTRING
                      THEN
                        #tempWillFlag := TRUE;
                        CASE #statWillQos OF
                          #MQTT_QOS_0:  // Statement section case 1
                            #tempWillQoS1 := FALSE;
                            #tempWillQoS2 := FALSE;
                          #MQTT_QOS_1:  // Statement section case 2 to 4
                            #tempWillQoS1 := TRUE;
                            #tempWillQoS2 := FALSE;
                          #MQTT_QOS_2:
                            #tempWillQoS1 := FALSE;
                            #tempWillQoS2 := True;
                          ELSE  // Statement section ELSE
                            ;
                        END_CASE;
                        FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#willtopic) DO
                          // Statement section FOR
                          "LMQTT_ConvertToUtf8"(character     := #willtopic[#tempLoopCounter],
                                                convertedUtf8 => #tempConvertedUtf8,
                                                bytesUsed     => #tempBytesUsedUtf8,
                                                error         => #tempErrorConvertUtf8,
                                                status        => #tempStatusConvertUtf8);
                          #statWillTopicLenUtf8Encoded := #statWillTopicLenUtf8Encoded + #tempBytesUsedUtf8;
                        END_FOR;
                        //Add WillTopic Len and Will Message Len (and len info twice)
                        #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statWillTopicLenUtf8Encoded + #statWillMessageCnt + (2 * #TWO_BYTE_LEN_INFO);
                      ELSE
                        #statWillTopicEncodeState := #NOT_USED_NO_ENCODING;
                        #statWillMessageEncodeState := #NOT_USED_NO_ENCODING;
                        #tempWillFlag := FALSE;
                        #statWillRetain := FALSE;
                        #tempWillQoS1 := FALSE;
                        #tempWillQoS2 := FALSE;
                      END_IF;
                      
                      //Build Connect Telegram
                      //Fixed Header - Write Paket Type
                      #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_CONNECT; // 1 Byte
                      #statSendBufferPos += 1; // increment
                      
                      //Write Remaining Paket Len info 
                      WHILE (#statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO)
                      DO//See MQTT Spec for explanation of this calculation
                        #statEncodedRemPaketLenAsByte := UDINT_TO_BYTE(#statSendPaketTotalRemLen MOD #SEND_LEN_MULTIPLIER_UDINT_128);
                        #statSendPaketTotalRemLen := #statSendPaketTotalRemLen / #SEND_LEN_MULTIPLIER_UDINT_128;
                        // if there are more data to encode, set the top bit of this byte
                        IF #statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO
                        THEN
                          // Do this and continue while loop
                          #statEncodedRemPaketLenAsByte := #statEncodedRemPaketLenAsByte OR UDINT_TO_BYTE(#SEND_LEN_MULTIPLIER_UDINT_128);
                          #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                          #statSendBufferPos += 1;
                        ELSE
                          //do this and leave while loop
                          #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                          #statSendBufferPos += 1;
                        END_IF;
                      END_WHILE;
                      
                      //Build Connect Telegram
                      // Write Protocol name
                      #statSendBuffer[#statSendBufferPos] := #CONN_PROTOCOL_NAME_0;
                      #statSendBufferPos += 1;
                      #statSendBuffer[#statSendBufferPos] := #CONN_PROTOCOL_NAME_4;
                      #statSendBufferPos += 1;
                      #statSendBuffer[#statSendBufferPos] := CHAR_TO_BYTE('M');
                      #statSendBufferPos += 1;
                      #statSendBuffer[#statSendBufferPos] := CHAR_TO_BYTE('Q');
                      #statSendBufferPos += 1;
                      #statSendBuffer[#statSendBufferPos] := CHAR_TO_BYTE('T');
                      #statSendBufferPos += 1;
                      #statSendBuffer[#statSendBufferPos] := CHAR_TO_BYTE('T');
                      #statSendBufferPos += 1;
                      //Write Protocol Level
                      #statSendBuffer[#statSendBufferPos] := #CONN_PROTOCOL_MQTT_VERSION_3_1_1;
                      #statSendBufferPos += 1;
                      //Write Connect Flags
                      #statSendBuffer[#statSendBufferPos].%X0 := false;
                      #statSendBuffer[#statSendBufferPos].%X1 := True;
                      #statSendBuffer[#statSendBufferPos].%X2 := #tempWillFlag;
                      #statSendBuffer[#statSendBufferPos].%X3 := #tempWillQoS1;
                      #statSendBuffer[#statSendBufferPos].%X4 := #tempWillQoS2;
                      #statSendBuffer[#statSendBufferPos].%X5 := #statWillRetain;
                      #statSendBuffer[#statSendBufferPos].%X6 := #tempPasswordFlag;
                      #statSendBuffer[#statSendBufferPos].%X7 := #tempUserFlag;
                      #statSendBufferPos += 1;
                      //Write Keep Alive in sec
                      #tempWordForSliceAddress := UINT_TO_WORD(#connParam.keepAlive);
                      #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1;
                      #statSendBufferPos += 1;
                      #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0;
                      #statSendBufferPos += 1;
                      
                      //Set To Complete this, can skip in further progess
                      #statPaketHeaderEncodeDone := TRUE;
                    END_IF;
                    
                    // Payload
                    // These fields, if present, MUST appear in the order:
                    // Client Identifier, Will topic, Will message, User Name, password
                    
                    
                    //ClientIdentifier
                    IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                      CASE #statClientIdEncodeState OF
                        #FIRST_ENCODING:  // Statement section case 1
                          //ADD len info into paket
                          
                          #tempWordForSliceAddress := UINT_TO_WORD(#statClientIdLenUtf8Encoded);
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                          #statSendBufferPos += 1;
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                          #statSendBufferPos += 1;
                          
                          FOR #tempLoopCounter := #statClientIdPos TO LEN(#clientIdentifier) DO
                            "LMQTT_ConvertToUtf8"(character     := #clientIdentifier[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              #statClientIdPos += 1;
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              #statClientIdEncodeState := #SUBSEQUENT_ENCODING;
                              EXIT;
                            END_IF;
                          END_FOR;
                          IF #statClientIdPos >= LEN(#clientIdentifier) THEN
                            #statClientIdEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                          
                        #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                          FOR #tempLoopCounter := #statClientIdPos TO LEN(#clientIdentifier) DO
                            "LMQTT_ConvertToUtf8"(character     := #clientIdentifier[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              #statClientIdPos += 1;
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              EXIT;
                            END_IF;
                          END_FOR;
                          IF #statClientIdPos >= LEN(#clientIdentifier) THEN
                            #statClientIdEncodeState := #ENCODE_DONE;
                          END_IF;
                        ELSE  // Statement section ELSE
                          ; // IDLE / SKIP
                      END_CASE;
                    END_IF;
                    
                    // Will Topic
                    // If the Will Flag is set to 1, the Will Topic is the next field in the payload. It must be > 0 Bytes
                    
                    IF #statClientIdEncodeState = #ENCODE_DONE
                      AND #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                      //When Client Id is encoded and buffer not full
                      //And willTopic is used
                      CASE #statWillTopicEncodeState OF
                        #FIRST_ENCODING:  // Statement section case 1
                          //ADD len info into paket
                          
                          #tempWordForSliceAddress := UINT_TO_WORD(#statWillTopicLenUtf8Encoded);
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                          #statSendBufferPos += 1;
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                          #statSendBufferPos += 1;
                          
                          FOR #tempLoopCounter := #statWillTopicPos TO LEN(#willtopic) DO
                            "LMQTT_ConvertToUtf8"(character     := #willtopic[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              //Increment when successful
                              #statWillTopicPos += 1;
                              
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              #statWillTopicEncodeState := #SUBSEQUENT_ENCODING;
                              EXIT;
                            END_IF;
                          END_FOR;
                          
                          IF #statWillTopicPos >= LEN(#willtopic) THEN
                            #statWillTopicEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                          FOR #tempLoopCounter := #statWillTopicPos TO LEN(#willtopic) DO
                            "LMQTT_ConvertToUtf8"(character     := #willtopic[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              #statWillTopicPos += 1;
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              EXIT;
                            END_IF;
                          END_FOR;
                          IF #statWillTopicPos >= LEN(#willtopic) THEN
                            #statWillTopicEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        ELSE  // Statement section ELSE
                          ;
                      END_CASE;
                    END_IF;
                    
                    // Will Message
                    // This field consists OF a two Byte length followed BY the payload FOR the Will message expressed as a sequence bytes.
                    
                    IF #statClientIdEncodeState = #ENCODE_DONE
                      AND #statWillTopicEncodeState = #ENCODE_DONE
                      AND #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                      //When Client Id is encoded and buffer not full
                      CASE #statWillMessageEncodeState OF
                        #FIRST_ENCODING:  // Statement section case 1
                          //ADD len info into paket
                          
                          #tempWordForSliceAddress := UINT_TO_WORD(#statWillMessageCnt);
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                          #statSendBufferPos += 1;
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                          #statSendBufferPos += 1;
                          
                          #tempLowerWillMsgArrayBoundary := LOWER_BOUND(ARR := #willMsgPayload, DIM := #ONE_DIMENSION);
                          
                          FOR #tempLoopCounter := #statWillMessagePos TO UINT_TO_DINT(#statWillMessageCnt - 1) DO
                            IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND THEN
                              #statSendBuffer[#statSendBufferPos] := #willMsgPayload[#tempLowerWillMsgArrayBoundary + #tempLoopCounter];
                              #statSendBufferPos += 1;
                              //Increment when successful
                              #statWillMessagePos += 1;
                            ELSE
                              //When buffer full
                              #statWillMessageEncodeState := #SUBSEQUENT_ENCODING;
                              EXIT;
                            END_IF;
                          END_FOR;
                          // If everything was copied successfull
                          IF #statWillMessagePos >= #statWillMessageCnt THEN
                            #statWillMessageEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                          #tempLowerWillMsgArrayBoundary := LOWER_BOUND(ARR := #willMsgPayload, DIM := #ONE_DIMENSION);
                          
                          FOR #tempLoopCounter := #statWillMessagePos TO UINT_TO_DINT(#statWillMessageCnt - 1) DO
                            IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND THEN
                              #statSendBuffer[#statSendBufferPos] := #willMsgPayload[#tempLowerWillMsgArrayBoundary + #tempLoopCounter];
                              #statSendBufferPos += 1;
                              //Increment when successful
                              #statWillMessagePos += 1;
                            ELSE
                              //When Buffer Full
                              EXIT;
                            END_IF;
                          END_FOR;
                          // If everything was copied successfull
                          IF #statWillMessagePos >= #statWillMessageCnt THEN
                            #statWillMessageEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                          
                        ELSE  // Statement section ELSE
                          ;
                      END_CASE;
                    END_IF;
                    
                    // Username
                    // If the Username Flag is set to 1, the Username the next field in the payload. It must be > 0 Bytes
                    
                    IF #statClientIdEncodeState = #ENCODE_DONE
                      AND (#statWillTopicEncodeState = #ENCODE_DONE OR #statWillTopicEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statWillMessageEncodeState = #ENCODE_DONE OR #statWillTopicEncodeState = #NOT_USED_NO_ENCODING)
                      AND #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                      //When Will Topic and Will Message is encoded and buffer not full
                      CASE #statUserNameEncodeState OF
                        #FIRST_ENCODING:  // Statement section case 1
                          //ADD len info into paket
                          
                          #tempWordForSliceAddress := UINT_TO_WORD(#statUsernameLenUtf8Encoded);
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                          #statSendBufferPos += 1;
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                          #statSendBufferPos += 1;
                          
                          FOR #tempLoopCounter := #statUserNamePos TO LEN(#username) DO
                            "LMQTT_ConvertToUtf8"(character     := #username[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              //Increment when successful
                              #statUserNamePos += 1;
                              
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              #statUserNameEncodeState := #SUBSEQUENT_ENCODING;
                              EXIT;
                            END_IF;
                          END_FOR;
                          
                          IF #statUserNamePos >= LEN(#username) THEN
                            #statUserNameEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                          FOR #tempLoopCounter := #statUserNamePos TO LEN(#username) DO
                            "LMQTT_ConvertToUtf8"(character     := #username[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              #statUserNamePos += 1;
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              EXIT;
                            END_IF;
                          END_FOR;
                          IF #statUserNamePos >= LEN(#username) THEN
                            #statUserNameEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        ELSE  // Statement section ELSE
                          ;
                      END_CASE;
                    END_IF;
                    
                    // Password
                    // If the Password Flag is set to 1, the Password the next field in the payload. It must be > 0 Bytes
                    //Password field contains 0 to 65535 bytes OF binary data prefixed with a two Byte length field which indicates the number OF bytes used
                    
                    IF #statClientIdEncodeState = #ENCODE_DONE
                      AND (#statWillTopicEncodeState = #ENCODE_DONE OR #statWillTopicEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statWillMessageEncodeState = #ENCODE_DONE OR #statWillMessageEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statUserNameEncodeState = #ENCODE_DONE OR #statUserNameEncodeState = #NOT_USED_NO_ENCODING)
                      AND #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                      //When Will Topic and Will Message is encoded and buffer not full
                      CASE #statPasswordEncodeState OF
                        #FIRST_ENCODING:  // Statement section case 1
                          //ADD len info into paket
                          
                          #tempWordForSliceAddress := UINT_TO_WORD(#statPasswordLenUtf8Encoded);
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                          #statSendBufferPos += 1;
                          #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                          #statSendBufferPos += 1;
                          
                          FOR #tempLoopCounter := #statPasswordPos TO LEN(#password) DO
                            "LMQTT_ConvertToUtf8"(character     := #password[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              //Increment when successful
                              #statPasswordPos += 1;
                              
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              #statPasswordEncodeState := #SUBSEQUENT_ENCODING;
                              EXIT;
                            END_IF;
                          END_FOR;
                          
                          IF #statPasswordPos >= LEN(#password) THEN
                            #statPasswordEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                          FOR #tempLoopCounter := #statPasswordPos TO LEN(#password) DO
                            "LMQTT_ConvertToUtf8"(character     := #password[#tempLoopCounter],
                                                  convertedUtf8 => #tempConvertedUtf8,
                                                  bytesUsed     => #tempBytesUsedUtf8,
                                                  error         => #tempErrorConvertUtf8,
                                                  status        => #tempStatusConvertUtf8);
                            
                            IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                              #statPasswordPos += 1;
                              CASE #tempBytesUsedUtf8 OF
                                #UTF_1_BYTE_USED:  // Statement section case 1
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                #UTF_2_BYTE_USED:
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                  #statSendBufferPos += 1;
                                  #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                  #statSendBufferPos += 1;
                                ELSE  // Statement section ELSE
                                  ;
                              END_CASE;
                            ELSE
                              //When buffer full
                              EXIT;
                            END_IF;
                          END_FOR;
                          IF #statPasswordPos >= LEN(#password) THEN
                            #statPasswordEncodeState := #ENCODE_DONE;
                          END_IF;
                          
                        ELSE  // Statement section ELSE
                          ;
                      END_CASE;
                    END_IF;
                    
                    //set Sendlen for TSendC Block
                    #statTsendcLen := #statSendBufferPos; // Buffer pos equals amount of elements in send array
                    //reset buffer pos
                    #statSendBufferPos := 0;
                    //enable Send Req
                    #statTsendcReq := TRUE;
                    //Set Watchdog
                    #statEnableTimerCommandWatchdog := TRUE;
                    //wait for send to be done
                    #statMqttConnectState := #MQTT_CONNECT_STATE_SEND_PAKET_WAIT_FOR_CONNACK;
                  END_IF;
                END_REGION BUILD_CONNECT_PAKET
                
              #MQTT_CONNECT_STATE_SEND_PAKET_WAIT_FOR_CONNACK:
                REGION SEND_CONNECT_PAKET_WAIT_FOR_CONNACK
                  //check tsend status
                  IF NOT #tempTsendcBusy AND #tempTsendcStatus = #TSENDC_JOB_DONE THEN
                    IF (#statClientIdEncodeState = #ENCODE_DONE OR #statClientIdEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statWillTopicEncodeState = #ENCODE_DONE OR #statWillTopicEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statWillMessageEncodeState = #ENCODE_DONE OR #statWillMessageEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statUserNameEncodeState = #ENCODE_DONE OR #statUserNameEncodeState = #NOT_USED_NO_ENCODING)
                      AND (#statPasswordEncodeState = #ENCODE_DONE OR #statPasswordEncodeState = #NOT_USED_NO_ENCODING) THEN
                      //Encoding done all sent
                      #statPaketHeaderEncodeDone := FALSE;
                    ELSE
                      // More to Encode and send
                      #statEnableTimerCommandWatchdog := FALSE;
                      #statMqttConnectState := #MQTT_CONNECT_STATE_BUILD_PAKET;
                    END_IF;
                  END_IF;
                  //Check watchdog
                  IF #instTimerCommandWatchdog.Q THEN
                    #statEnableTimerCommandWatchdog := FALSE;
                    #statPaketHeaderEncodeDone := FALSE;
                    #statStatus := #ERR_MQTT_CONNECT_TIMEOUT; // Set correct status that identifies error clearly
                    #statSubfunctionStatus := #ERR_MQTT_CONNECT_TIMEOUT; // Status or return value of called FBs, FCs and system blocks
                    #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                    #statErrorAutoCleared := TRUE;
                    #statMqttConnectState := #MQTT_CONNECT_STATE_BUILD_PAKET;
                    
                  END_IF;
                  
                  //Check Connect ACK paket
                  CASE #tempMqttConnAckRcvStatus OF
                    #NO_RESPONSE:  //  IDLE
                      ;
                    #RESPONSE_GOOD:  // Statement section case 2 to 4
                      //disable watchdog
                      #statEnableTimerCommandWatchdog := FALSE;
                      //Encoding done all sent
                      #statPaketHeaderEncodeDone := FALSE;
                      //Go to Connected
                      #statMqttConnectState := #MQTT_CONNECT_STATE_CONNECTED;
                      #statStatus := #STATUS_MQTT_CONNECTED;
                  END_CASE;
                END_REGION REGION SEND_CONNECT_PAKET
                
              #MQTT_CONNECT_STATE_CONNECTED:
                REGION CONNECTED
                  //Check Rising edge of input commands
                  #tempCommandInput.%X0 := #tempPublish AND NOT #statPublishOld;
                  #tempCommandInput.%X1 := #tempSubscribe AND NOT #statSubscribeOld;
                  #tempCommandInput.%X2 := #tempUnsubscribe AND NOT #statUnsubscribeOld;
                  
                  //Start the keepalive timer if used
                  #statEnableMqttKeepAliveTimer := #statMqttKeepAliveUsed;
                  
                  //set status to connected after successfully executed job
                  IF #statStatus = #STATUS_JOB_EXECUTED THEN
                    #statStatus := #STATUS_MQTT_CONNECTED;
                  END_IF;
                  
                  //Reset done bit
                  IF #statDone = TRUE
                    AND #tempPublish = FALSE AND #tempSubscribe = FALSE AND #tempUnsubscribe = FALSE
                  THEN
                    #statDone := FALSE;
                  END_IF;
                  
                  REGION MQTT_COMMANDS
                    //When state machine is ready for a new input then assign correct command
                    //Ping job can be overwritten by a command.
                    IF #tempCommandInput <> #NO_COMMAND
                      AND (#statMqttCommandState = #MQTT_COMMAND_STATE_NO_PROCESSING OR #statMqttCommandState = #MQTT_COMMAND_STATE_SEND_PING)
                    THEN
                      // New Input set, reset done flag
                      #statDone := FALSE;
                      #statMqttCommandState := BYTE_TO_DINT(#tempCommandInput);
                    END_IF;
                    
                    CASE #statMqttCommandState OF
                      #MQTT_COMMAND_STATE_NO_PROCESSING:
                        //EMPTY STATE
                        ;
                      #MQTT_COMMAND_STATE_BUILD_PUBLISH:  // Statement section case 1
                        REGION PUBLISH_TO_TOPIC
                          //Remaining Length is the length of the variable header (TOPIC NAME + PacketID) plus the length of the Payload. 
                          //Max Len of Mqtt pakets is per Standard 268,435,455 Bytes (ff,ff,ff,7f)
                          //Calculate Remain Len will be
                          //Len of TOPIC   (max 3*16382 WChars= 49.146 Bytes)
                          //plus Len of PacketID (2 Bytes)
                          //plus Len of Payload (max 268,435,455 - 49.146 - 2 = 268.386.307 Bytes ca. 268 MB)
                          //Max Array / DB Len in TIA portal is around 16 MB or 16.777.216 Byte
                          //Set Status
                          #statStatus := #STATUS_MQTT_PUBLISH;
                          
                          // Must obey, if not currently sending PubAck Msg on a subscription
                          // Else, try in the next cycle
                          IF #tempTsendcBusy = FALSE // when tsendC is ready
                            AND #tempTsendcDone = FALSE // tsendC did not finish in this cycle
                            AND #statTsendcReq = FALSE // TsendC request was not already requested by pub ack msg
                          THEN
                            IF #statPaketHeaderEncodeDone = FALSE THEN
                              
                              //Init
                              #statSendPaketTotalRemLen := 0;
                              #statSendBufferPos := 0;
                              #statPublishQos := #qos;
                              #statPublishMessageCnt := #publishMsgLen;
                              #statPublishTopicEncodeState := #FIRST_ENCODING;
                              #statPublishTopicPos := #FIRST_CHARACTER;
                              #statPublishTopicLenUtf8Encoded := 0;
                              #statPaketId += 1;//increment
                              #statPaketIdEncoded := FALSE;
                              #statPublishEncodeMessageState := #SUBSEQUENT_ENCODING; // No len info necessary so start directly at subsequent.
                              #statPublishMessagePos := 0; // first array element
                              
                              //verify PayloadLen
                              #tempMaxPublishDataArrayLen := ABS(UPPER_BOUND(ARR := #publishMsgPayload, DIM := #ONE_DIMENSION) - LOWER_BOUND(ARR := #publishMsgPayload, DIM := #ONE_DIMENSION)) + #ARRAY_LEN_OFFSET_PLUS_1;
                              
                              //check necessary boundaries
                              IF #tempMaxPublishDataArrayLen < #statPublishMessageCnt THEN
                                #statStatus := #ERR_CNT_EXCEEDS_ARRAY_DIMENSION; // Set correct status that identifies error clearly
                                #statSubfunctionStatus := #ERR_CNT_EXCEEDS_ARRAY_DIMENSION; // Status or return value of called FBs, FCs and system blocks
                                #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                                #statErrorAutoCleared := TRUE;
                                #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              ELSIF LEN(#mqttTopic) = #LEN_NULL THEN
                                #statStatus := #ERR_MQTT_COMMAND_PUBLISH_TOPIC_INVALID; // Set correct status that identifies error clearly
                                #statSubfunctionStatus := #ERR_MQTT_COMMAND_PUBLISH_TOPIC_INVALID; // Status or return value of called FBs, FCs and system blocks
                                #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                                #statErrorAutoCleared := TRUE;
                                #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              ELSIF #statPublishQos > #MQTT_QOS_2 THEN
                                #statStatus := #ERR_QOS_INVALID; // Set correct status that identifies error clearly
                                #statSubfunctionStatus := #ERR_QOS_INVALID; // Status or return value of called FBs, FCs and system blocks
                                #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                                #statErrorAutoCleared := TRUE;
                                #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              ELSE // All ok
                                //Add amount of bytes for publish message
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statPublishMessageCnt;
                                //add publish  topic len
                                FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#mqttTopic) DO
                                  "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                        convertedUtf8 => #tempConvertedUtf8,
                                                        bytesUsed     => #tempBytesUsedUtf8,
                                                        error         => #tempErrorConvertUtf8,
                                                        status        => #tempStatusConvertUtf8);
                                  #statPublishTopicLenUtf8Encoded := #statPublishTopicLenUtf8Encoded + #tempBytesUsedUtf8;
                                END_FOR;
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statPublishTopicLenUtf8Encoded + #TWO_BYTE_LEN_INFO;
                                
                                //Build Publish Telegram
                                //Fixed Header - Write Paket Type
                                #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_PUBLISH;
                                // Set DUP flag always to FALSE
                                #statSendBuffer[#statSendBufferPos].%X3 := FALSE;
                                // Set QoS Level
                                CASE #statPublishQos OF
                                  #MQTT_QOS_0:  // Statement section case 0
                                    #statSendBuffer[#statSendBufferPos].%X2 := FALSE;
                                    #statSendBuffer[#statSendBufferPos].%X1 := FALSE;
                                  #MQTT_QOS_1:  // Statement section case 1
                                    #statSendBuffer[#statSendBufferPos].%X2 := FALSE;
                                    #statSendBuffer[#statSendBufferPos].%X1 := TRUE;
                                    //Add two byte len info for Mandatory packet ID
                                    #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #TWO_BYTE_LEN_INFO;
                                  #MQTT_QOS_2: // Statement section case 2
                                    #statSendBuffer[#statSendBufferPos].%X2 := TRUE;
                                    #statSendBuffer[#statSendBufferPos].%X1 := FALSE;
                                    //Add two byte len info for Mandatory packet ID
                                    #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #TWO_BYTE_LEN_INFO;
                                  ELSE
                                    ;
                                END_CASE;
                                //Set retain bit
                                #statSendBuffer[#statSendBufferPos].%X0 := #retain;
                                
                                #statSendBufferPos += 1; // increment
                                
                                //Write Remaining Paket Len info 
                                WHILE (#statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO)
                                DO//See MQTT Spec for explanation of this calculation
                                  #statEncodedRemPaketLenAsByte := UDINT_TO_BYTE(#statSendPaketTotalRemLen MOD #SEND_LEN_MULTIPLIER_UDINT_128);
                                  #statSendPaketTotalRemLen := #statSendPaketTotalRemLen / #SEND_LEN_MULTIPLIER_UDINT_128;
                                  // if there are more data to encode, set the top bit of this byte
                                  IF #statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO
                                  THEN
                                    // Do this and continue while loop
                                    #statEncodedRemPaketLenAsByte := #statEncodedRemPaketLenAsByte OR UDINT_TO_BYTE(#SEND_LEN_MULTIPLIER_UDINT_128);
                                    #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                                    #statSendBufferPos += 1;
                                  ELSE
                                    //do this and leave while loop
                                    #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                                    #statSendBufferPos += 1;
                                  END_IF;
                                END_WHILE;
                                //When all done, set encode to true
                                #statPaketHeaderEncodeDone := TRUE;
                              END_IF;
                            END_IF;
                            
                            //Header Encoded - now Topic, PacketId and Message need to be encoded.
                            IF #statPaketHeaderEncodeDone = TRUE THEN
                              
                              //Publish Topic
                              IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                                CASE #statPublishTopicEncodeState OF
                                  #FIRST_ENCODING:  // Statement section case 1
                                    //ADD len info into paket
                                    
                                    #tempWordForSliceAddress := UINT_TO_WORD(#statPublishTopicLenUtf8Encoded);
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                    #statSendBufferPos += 1;
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                                    #statSendBufferPos += 1;
                                    
                                    FOR #tempLoopCounter := #statPublishTopicPos TO LEN(#mqttTopic) DO
                                      "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                            convertedUtf8 => #tempConvertedUtf8,
                                                            bytesUsed     => #tempBytesUsedUtf8,
                                                            error         => #tempErrorConvertUtf8,
                                                            status        => #tempStatusConvertUtf8);
                                      
                                      IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                                        #statPublishTopicPos += 1;
                                        CASE #tempBytesUsedUtf8 OF
                                          #UTF_1_BYTE_USED:  // Statement section case 1
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                          #UTF_2_BYTE_USED:
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                          #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                            #statSendBufferPos += 1;
                                          ELSE  // Statement section ELSE
                                            ;
                                        END_CASE;
                                      ELSE
                                        //When buffer full
                                        #statPublishTopicEncodeState := #SUBSEQUENT_ENCODING;
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    IF #statPublishTopicPos >= LEN(#mqttTopic) THEN
                                      #statPublishTopicEncodeState := #ENCODE_DONE;
                                    END_IF;
                                    
                                    
                                  #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                                    FOR #tempLoopCounter := #statPublishTopicPos TO LEN(#mqttTopic) DO
                                      
                                      "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                            convertedUtf8 => #tempConvertedUtf8,
                                                            bytesUsed     => #tempBytesUsedUtf8,
                                                            error         => #tempErrorConvertUtf8,
                                                            status        => #tempStatusConvertUtf8);
                                      IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                                        #statPublishTopicPos += 1;
                                        CASE #tempBytesUsedUtf8 OF
                                          #UTF_1_BYTE_USED:  // Statement section case 1
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                          #UTF_2_BYTE_USED:
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                          #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                            #statSendBufferPos += 1;
                                          ELSE  // Statement section ELSE
                                            ;
                                        END_CASE;
                                      ELSE
                                        //When buffer full
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    IF #statPublishTopicPos >= LEN(#mqttTopic) THEN
                                      #statPublishTopicEncodeState := #ENCODE_DONE;
                                    END_IF;
                                  ELSE  // SKIP if done
                                    ;
                                END_CASE;
                              END_IF;
                              
                              // Encode MessageID, when QOS > 0 and  Topic done and buffer not full
                              IF #statPublishTopicEncodeState = #ENCODE_DONE
                                AND #statPaketIdEncoded = FALSE
                                AND #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                                // Check QoS - only necessary if QoS >0
                                CASE #statPublishQos OF
                                  #MQTT_QOS_1:
                                    #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                    #statSendBufferPos += 1;
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; //LSB
                                    #statSendBufferPos += 1;
                                  #MQTT_QOS_2:
                                    #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                    #statSendBufferPos += 1;
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; //LSB
                                    #statSendBufferPos += 1;
                                  ELSE
                                    //No paket id to encode here
                                    ;
                                END_CASE;
                                //Finally:
                                #statPaketIdEncoded := TRUE;
                              END_IF;
                              
                              // Encode Payload, when  Topic done and PaketID Done and buffer not full
                              IF #statPublishTopicEncodeState = #ENCODE_DONE
                                AND #statPaketIdEncoded = TRUE
                                AND #statSendBufferPos < #MAX_BUFFER_LEN_SEND THEN
                                
                                // Publish Message Encoding
                                // This Contains the payload from the publish message expressed as a sequence bytes.
                                CASE #statPublishEncodeMessageState OF
                                  #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                                    #tempLowerBoundPublishDataArray := LOWER_BOUND(ARR := #publishMsgPayload, DIM := #ONE_DIMENSION);
                                    
                                    FOR #tempLoopCounter := #statPublishMessagePos TO UDINT_TO_DINT(#statPublishMessageCnt - 1) DO
                                      IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND THEN
                                        #statSendBuffer[#statSendBufferPos] := #publishMsgPayload[#tempLowerBoundPublishDataArray + #tempLoopCounter];
                                        #statSendBufferPos += 1;
                                        //Increment when successful
                                        #statPublishMessagePos += 1;
                                      ELSE
                                        //When Buffer Full
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    // If everything was copied successfull
                                    IF #statPublishMessagePos >= #statPublishMessageCnt THEN
                                      #statPublishEncodeMessageState := #ENCODE_DONE;
                                    END_IF;
                                  ELSE  // Statement section ELSE
                                    ;
                                END_CASE;
                              END_IF;
                              
                              //set Sendlen for TSendC Block
                              #statTsendcLen := #statSendBufferPos; // Buffer pos equals amount of elements in send array
                              //reset buffer pos
                              #statSendBufferPos := 0;
                              //enable Send Req
                              #statTsendcReq := TRUE;
                              //Set Watchdog
                              #statEnableTimerCommandWatchdog := TRUE;
                              //wait for send to be done
                              #statMqttCommandState := #MQTT_COMMAND_STATE_SEND_PUBLISH;
                            END_IF;
                          END_IF;
                        END_REGION PUBLISH_TO_TOPIC
                        
                      #MQTT_COMMAND_STATE_SEND_PUBLISH:
                        REGION SEND_PUBLISH_WAIT_FOR_RESPONSE
                          //check tsend status
                          IF NOT #tempTsendcBusy AND #tempTsendcStatus = #TSENDC_JOB_DONE THEN
                            
                            IF (#statPublishTopicEncodeState = #ENCODE_DONE)
                              AND (#statPublishEncodeMessageState = #ENCODE_DONE) THEN
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                              //  with QoS = 0 Job done
                              IF #statPublishQos = #MQTT_QOS_0 THEN
                                // job done
                                #statDone := TRUE;
                                // go back to idle
                                #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                                //reset Watchdog
                                #statEnableTimerCommandWatchdog := FALSE;
                                // Set Status back to connected
                                #statStatus := #STATUS_JOB_EXECUTED;
                              END_IF;
                            ELSE
                              // More to Encode and send
                              #statEnableTimerCommandWatchdog := FALSE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_BUILD_PUBLISH;
                            END_IF;
                            
                          END_IF;
                          IF (#instTsendC.STATUS = #TSENDC_JOB_DONE OR #instTsendC.STATUS =#TSENDC_EST_OK)THEN
                            #statPubRecReady := 1;
                          ELSE
                            #statPubRecReady := 0;
                            
                          END_IF;
                          
                          //check watchdog
                          IF #instTimerCommandWatchdog.Q THEN
                            #statEnableTimerCommandWatchdog := FALSE;
                            #statStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Set correct status that identifies error clearly
                            #statSubfunctionStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Status or return value of called FBs, FCs and system blocks
                            #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                            #statErrorAutoCleared := TRUE;
                            #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                            
                            
                          END_IF;
                          
                          //When QoS = 1; Wait for Publish ACK paket
                          CASE #tempMqttPubAckRcv OF
                            #NO_RESPONSE:  // Statement section case 0 IDLE
                              ;
                            #RESPONSE_GOOD:  // Statement section case 1 OKAY
                              //disable watchdog
                              #statEnableTimerCommandWatchdog := FALSE;
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                              //Publish QoS 1 = Done
                              #statDone := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              // Set Status back to connected
                              #statStatus := #STATUS_JOB_EXECUTED;
                            #RESPONSE_PAKET_ID_INVALID:
                              #statStatus := #ERR_MQTT_PAKET_ID_INVALID; // Set correct status that identifies error clearly
                              #statSubfunctionStatus := #ERR_MQTT_PAKET_ID_INVALID; // Status or return value of called FBs, FCs and system blocks
                              #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                              #statErrorAutoCleared := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_CASE;
                          
                          //When QOS = 2 and Pub Rec Receieved:
                          CASE #statMqttPubRecRcv OF
                            #NO_RESPONSE:  // 0 IDLE
                              ;
                            #RESPONSE_GOOD:
                              IF (#statPubRecReady) THEN
                                //Encoding done all sent
                                #statPaketHeaderEncodeDone := FALSE;
                                // Send Publish Release paket
                                #statSendBufferPos := 0;
                                #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_PUBREL;
                                #statSendBufferPos += 1;
                                //Remaining Lenght (must be 2)
                                #statSendBuffer[#statSendBufferPos] := #REMAINING_LEN_2;
                                #statSendBufferPos += 1;
                                // add paket id 
                                #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                                #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                #statSendBufferPos += 1;
                                #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; //LSB
                                #statSendBufferPos += 1;
                                #statTsendcLen := #statSendBufferPos;
                                //Start send request
                                #statTsendcReq := TRUE;
                                #statMqttPubRecRcv := 0;
                                #statPubRecReady := 0;
                                
                                
                                
                                
                                //Reset watchdog and start
                                RESET_TIMER(#instTimerCommandWatchdog);
                                #statEnableTimerCommandWatchdog := TRUE;
                              END_IF;
                              //Stay in State
                            #RESPONSE_PAKET_ID_INVALID:
                              #statStatus := #ERR_MQTT_PAKET_ID_INVALID; // Set correct status that identifies error clearly
                              #statSubfunctionStatus := #ERR_MQTT_PAKET_ID_INVALID; // Status or return value of called FBs, FCs and system blocks
                              #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                              #statErrorAutoCleared := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_CASE;
                          
                          //When QOS = 2 and Pub Complete Receieved:
                          CASE #tempMqttPubCompRcv OF
                            #NO_RESPONSE:  // Idle
                              ;
                            #RESPONSE_GOOD:  //When QOS = 2 and Pub Complete Receieved:
                              //disable watchdog
                              #statEnableTimerCommandWatchdog := FALSE;
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                              //Publish QoS 2 = Done
                              #statDone := TRUE;
                              
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              // Set Status back to connected
                              #statStatus := #STATUS_JOB_EXECUTED;
                            #RESPONSE_PAKET_ID_INVALID:
                              #statStatus := #ERR_MQTT_PAKET_ID_INVALID; // Set correct status that identifies error clearly
                              #statSubfunctionStatus := #ERR_MQTT_PAKET_ID_INVALID; // Status or return value of called FBs, FCs and system blocks
                              #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                              #statErrorAutoCleared := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_CASE;
                        END_REGION MQTT_COMMAND_SEND_PUBLISH
                        
                      #MQTT_COMMAND_STATE_BUILD_SUBSCRIBE:  // Statement section case 2 
                        REGION SUBSCRIBE_TO_TOPIC
                          //Remaining Length is the length of the variable header (PacketID, 2Bytes) plus the length of the Payload. 
                          //Max Len of Mqtt pakets is per Standard 268,435,455 Bytes (ff,ff,ff,7f)
                          //Calculate Remain Len will be
                          //Len of TOPIC   (max 3*16382 WChars= 49.146 Bytes)
                          //LenInfo Topic (2Byte)
                          //QoS of Topic (1Byte)
                          //
                          //Set Status
                          #statStatus := #STATUS_MQTT_SUBSCRIBE;
                          // Must obey, if not currently sending PubAck Msg on a subscription
                          // Else, try in the next cycle
                          IF #tempTsendcBusy = FALSE // when tsendC is ready
                            AND #tempTsendcDone = FALSE // tsendC did not finish in this cycle
                            AND #statTsendcReq = FALSE // TsendC request was not already requested by pub ack msg
                          THEN
                            IF #statPaketHeaderEncodeDone = FALSE THEN
                              
                              //Init
                              #statSendPaketTotalRemLen := 0;
                              #statSendBufferPos := 0;
                              #statSubscribeQos := #qos;
                              #statSubscribeTopicEncodeState := #FIRST_ENCODING;
                              #statSubscribeTopicPos := #FIRST_CHARACTER;
                              #statSubscribeTopicLenUtf8Encoded := 0;
                              #statPaketId += 1;//increment
                              #statSubscribeQosEncoded := FALSE;
                              
                              //check necessary boundaries
                              
                              IF LEN(#mqttTopic) = #LEN_NULL THEN
                                #statStatus := #ERR_MQTT_COMMAND_SUBSCRIBE_TOPIC_INVALID; // Set correct status that identifies error clearly
                                #statSubfunctionStatus := #ERR_MQTT_COMMAND_SUBSCRIBE_TOPIC_INVALID; // Status or return value of called FBs, FCs and system blocks
                                #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                                #statErrorAutoCleared := TRUE;
                                #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              ELSIF #statSubscribeQos > #MQTT_QOS_1 THEN
                                #statStatus := #ERR_QOS_INVALID; // Set correct status that identifies error clearly
                                #statSubfunctionStatus := #ERR_QOS_INVALID; // Status or return value of called FBs, FCs and system blocks
                                #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                                #statErrorAutoCleared := TRUE;
                                #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              ELSE // All ok
                                //Add two Byte for Paket ID:
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #TWO_BYTE_LEN_INFO;
                                //Add one Byte for QoS Info:
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #ONE_BYTE_LEN_INFO;
                                //add subscribe  topic len
                                FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#mqttTopic) DO
                                  "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                        convertedUtf8 => #tempConvertedUtf8,
                                                        bytesUsed     => #tempBytesUsedUtf8,
                                                        error         => #tempErrorConvertUtf8,
                                                        status        => #tempStatusConvertUtf8);
                                  #statSubscribeTopicLenUtf8Encoded := #statSubscribeTopicLenUtf8Encoded + #tempBytesUsedUtf8;
                                END_FOR;
                                //Add len of topic plus len info
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statSubscribeTopicLenUtf8Encoded + #TWO_BYTE_LEN_INFO;
                                
                                //Build Subscribe Telegram
                                //Fixed Header - Write Paket Type
                                #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_SUBSCRIBE;
                                #statSendBufferPos += 1; // increment
                                
                                //Write Remaining Paket Len info 
                                WHILE (#statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO)
                                DO//See MQTT Spec for explanation of this calculation
                                  #statEncodedRemPaketLenAsByte := UDINT_TO_BYTE(#statSendPaketTotalRemLen MOD #SEND_LEN_MULTIPLIER_UDINT_128);
                                  #statSendPaketTotalRemLen := #statSendPaketTotalRemLen / #SEND_LEN_MULTIPLIER_UDINT_128;
                                  // if there are more data to encode, set the top bit of this byte
                                  IF #statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO
                                  THEN
                                    // Do this and continue while loop
                                    #statEncodedRemPaketLenAsByte := #statEncodedRemPaketLenAsByte OR UDINT_TO_BYTE(#SEND_LEN_MULTIPLIER_UDINT_128);
                                    #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                                    #statSendBufferPos += 1;
                                  ELSE
                                    //do this and leave while loop
                                    #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                                    #statSendBufferPos += 1;
                                  END_IF;
                                END_WHILE;
                                
                                // Set Paket Id
                                #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                                #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                #statSendBufferPos += 1;
                                #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; //LSB
                                #statSendBufferPos += 1;
                                
                                //When all done, set encode to true
                                #statPaketHeaderEncodeDone := TRUE;
                              END_IF;
                            END_IF;
                            //Header Encoded 
                            IF #statPaketHeaderEncodeDone = TRUE THEN
                              //Header Encoded - now Topic and qos encoding
                              
                              //Subscribe Topic
                              IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                                CASE #statSubscribeTopicEncodeState OF
                                  #FIRST_ENCODING:  // Statement section case 1
                                    //ADD len info into paket
                                    
                                    #tempWordForSliceAddress := UINT_TO_WORD(#statSubscribeTopicLenUtf8Encoded);
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                    #statSendBufferPos += 1;
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                                    #statSendBufferPos += 1;
                                    
                                    FOR #tempLoopCounter := #statSubscribeTopicPos TO LEN(#mqttTopic) DO
                                      "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                            convertedUtf8 => #tempConvertedUtf8,
                                                            bytesUsed     => #tempBytesUsedUtf8,
                                                            error         => #tempErrorConvertUtf8,
                                                            status        => #tempStatusConvertUtf8);
                                      
                                      IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                                        #statSubscribeTopicPos += 1;
                                        CASE #tempBytesUsedUtf8 OF
                                          #UTF_1_BYTE_USED:  // Statement section case 1
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                          #UTF_2_BYTE_USED:
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                          #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                            #statSendBufferPos += 1;
                                          ELSE  // Statement section ELSE
                                            ;
                                        END_CASE;
                                      ELSE
                                        //When buffer full
                                        #statSubscribeTopicEncodeState := #SUBSEQUENT_ENCODING;
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    IF #statSubscribeTopicPos >= LEN(#mqttTopic) THEN
                                      #statSubscribeTopicEncodeState := #ENCODE_DONE;
                                    END_IF;
                                    
                                  #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                                    FOR #tempLoopCounter := #statSubscribeTopicPos TO LEN(#mqttTopic) DO
                                      
                                      "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                            convertedUtf8 => #tempConvertedUtf8,
                                                            bytesUsed     => #tempBytesUsedUtf8,
                                                            error         => #tempErrorConvertUtf8,
                                                            status        => #tempStatusConvertUtf8);
                                      IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                                        #statSubscribeTopicPos += 1;
                                        CASE #tempBytesUsedUtf8 OF
                                          #UTF_1_BYTE_USED:  // Statement section case 1
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                          #UTF_2_BYTE_USED:
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                          #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                            #statSendBufferPos += 1;
                                          ELSE  // Statement section ELSE
                                            ;
                                        END_CASE;
                                      ELSE
                                        //When buffer full
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    IF #statSubscribeTopicPos >= LEN(#mqttTopic) THEN
                                      #statSubscribeTopicEncodeState := #ENCODE_DONE;
                                    END_IF;
                                  ELSE  // Skip when Done
                                    ;
                                END_CASE;
                              END_IF;
                              
                              IF #statSubscribeTopicEncodeState = #ENCODE_DONE
                                AND #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #ONE_BYTE_LEN_INFO THEN
                                #statSendBuffer[#statSendBufferPos] := USINT_TO_BYTE(#statSubscribeQos);
                                #statSendBufferPos += 1;
                                #statSubscribeQosEncoded := TRUE;
                              END_IF;
                              
                              
                              //set Sendlen for TSendC Block
                              #statTsendcLen := #statSendBufferPos; // Buffer pos equals amount of elements in send array
                              //reset buffer pos
                              #statSendBufferPos := 0;
                              //enable Send Req
                              #statTsendcReq := TRUE;
                              //Set Watchdog
                              #statEnableTimerCommandWatchdog := TRUE;
                              //wait for send to be done
                              #statMqttCommandState := #MQTT_COMMAND_STATE_SEND_SUBSCRIBE;
                            END_IF;
                          END_IF;
                        END_REGION SUBSCRIBE_TO_TOPIC
                        
                      #MQTT_COMMAND_STATE_SEND_SUBSCRIBE:
                        REGION SEND_SUBSCRIBE_WAIT_FOR_RESPONSE
                          //check tsend status
                          IF NOT #tempTsendcBusy AND #tempTsendcStatus = #TSENDC_JOB_DONE THEN
                            IF #statSubscribeTopicEncodeState = #ENCODE_DONE
                              AND #statSubscribeQosEncoded = TRUE THEN
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                            ELSE
                              // More to Encode and send 
                              #statEnableTimerCommandWatchdog := FALSE; // reset watchdog
                              #statMqttCommandState := #MQTT_COMMAND_STATE_BUILD_SUBSCRIBE;
                            END_IF;
                          END_IF;
                          //Wait for timeout
                          IF #instTimerCommandWatchdog.Q THEN
                            #statEnableTimerCommandWatchdog := FALSE;
                            #statStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Set correct status that identifies error clearly
                            #statSubfunctionStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Status or return value of called FBs, FCs and system blocks
                            #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                            #statErrorAutoCleared := TRUE;
                            #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_IF;
                          
                          //Check Subscribe ACK paket
                          CASE #tempMqttSubAckRcv OF
                            #NO_RESPONSE:  // Statement section case 1
                              ;
                            #RESPONSE_GOOD:  // Statement section case 2 to 4
                              //disable watchdog
                              #statEnableTimerCommandWatchdog := FALSE;
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                              // Job done
                              #statDone := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              // Set Status back to connected
                              #statStatus := #STATUS_JOB_EXECUTED;
                            #RESPONSE_PAKET_ID_INVALID:  // PaketId Invalid
                              #statStatus := #ERR_MQTT_PAKET_ID_INVALID; // Set correct status that identifies error clearly
                              #statSubfunctionStatus := #ERR_MQTT_PAKET_ID_INVALID; // Status or return value of called FBs, FCs and system blocks
                              #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                              #statErrorAutoCleared := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                            #RESPONSE_SUBSCRIBE_FAILED:
                              #statStatus := #ERR_MQTT_SUBACK_FAILURE; // Set correct status that identifies error clearly
                              #statSubfunctionStatus := #ERR_MQTT_SUBACK_FAILURE; // Status or return value of called FBs, FCs and system blocks
                              #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                              #statErrorAutoCleared := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_CASE;
                        END_REGION SEND_SUBSCRIBE_WAIT_FOR_RESPONSE
                        
                      #MQTT_COMMAND_STATE_BUILD_UNSUBSCRIBE:// Unsubscribe from topics
                        REGION UNSUBSCRIBE_FROM_TOPIC
                          //Remaining Length is the length of the variable header (PacketID, 2Bytes) plus the length of the Payload. 
                          //Max Len of Mqtt pakets is per Standard 268,435,455 Bytes (ff,ff,ff,7f)
                          //Calculate Remain Len will be
                          //Len of TOPIC   (max 3*16382 WChars= 49.146 Bytes)
                          //LenInfo Topic (2Byte)
                          //
                          //Set Status
                          #statStatus := #STATUS_MQTT_UNSUBSCRIBE;
                          // Must obey, if not currently sending PubAck Msg on a subscription
                          // Else, try in the next cycle
                          IF #tempTsendcBusy = FALSE // when tsendC is ready
                            AND #tempTsendcDone = FALSE // tsendC did not finish in this cycle
                            AND #statTsendcReq = FALSE // TsendC request was not already requested by pub ack msg
                          THEN
                            //Header not encoded
                            IF #statPaketHeaderEncodeDone = FALSE THEN
                              //Init
                              #statSendPaketTotalRemLen := 0;
                              #statSendBufferPos := 0;
                              #statUnsubscribeTopicEncodeState := #FIRST_ENCODING;
                              #statUnsubscribeTopicPos := #FIRST_CHARACTER;
                              #statUnsubscribeTopicLenUtf8Encoded := 0;
                              #statPaketId += 1;//increment
                              
                              //check necessary boundaries
                              
                              IF LEN(#mqttTopic) = #LEN_NULL THEN
                                #statStatus := #ERR_MQTT_COMMAND_UNSUBSCRIBE_TOPIC_INVALID; // Set correct status that identifies error clearly
                                #statSubfunctionStatus := #ERR_MQTT_COMMAND_UNSUBSCRIBE_TOPIC_INVALID; // Status or return value of called FBs, FCs and system blocks
                                #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                                #statErrorUserCleared := TRUE;
                              ELSE // All ok
                                //Add two Byte for Paket ID:
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #TWO_BYTE_LEN_INFO;
                                //add unsubscribe  topic len
                                FOR #tempLoopCounter := #FIRST_CHARACTER TO LEN(#mqttTopic) DO
                                  "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                        convertedUtf8 => #tempConvertedUtf8,
                                                        bytesUsed     => #tempBytesUsedUtf8,
                                                        error         => #tempErrorConvertUtf8,
                                                        status        => #tempStatusConvertUtf8);
                                  #statUnsubscribeTopicLenUtf8Encoded := #statUnsubscribeTopicLenUtf8Encoded + #tempBytesUsedUtf8;
                                END_FOR;
                                //Add len of topic plus len info
                                #statSendPaketTotalRemLen := #statSendPaketTotalRemLen + #statUnsubscribeTopicLenUtf8Encoded + #TWO_BYTE_LEN_INFO;
                                
                                //Build Subscribe Telegram
                                //Fixed Header - Write Paket Type
                                #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_UNSUBSCRIBE;
                                #statSendBufferPos += 1; // increment
                                
                                //Write Remaining Paket Len info 
                                WHILE (#statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO)
                                DO//See MQTT Spec for explanation of this calculation
                                  #statEncodedRemPaketLenAsByte := UDINT_TO_BYTE(#statSendPaketTotalRemLen MOD #SEND_LEN_MULTIPLIER_UDINT_128);
                                  #statSendPaketTotalRemLen := #statSendPaketTotalRemLen / #SEND_LEN_MULTIPLIER_UDINT_128;
                                  // if there are more data to encode, set the top bit of this byte
                                  IF #statSendPaketTotalRemLen > #DEFAULT_VALUE_ZERO
                                  THEN
                                    // Do this and continue while loop
                                    #statEncodedRemPaketLenAsByte := #statEncodedRemPaketLenAsByte OR UDINT_TO_BYTE(#SEND_LEN_MULTIPLIER_UDINT_128);
                                    #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                                    #statSendBufferPos += 1;
                                  ELSE
                                    //do this and leave while loop
                                    #statSendBuffer[#statSendBufferPos] := #statEncodedRemPaketLenAsByte;
                                    #statSendBufferPos += 1;
                                  END_IF;
                                END_WHILE;
                                
                                // Set Paket Id
                                #tempWordForSliceAddress := UINT_TO_WORD(#statPaketId);
                                #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                #statSendBufferPos += 1;
                                #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; //LSB
                                #statSendBufferPos += 1;
                                
                                //When all done, set encode to true
                                #statPaketHeaderEncodeDone := TRUE;
                              END_IF;
                            END_IF;
                            
                            //Header Encoded - 
                            IF #statPaketHeaderEncodeDone = TRUE THEN
                              //Unsubscribe Topic
                              IF #statSendBufferPos <= #MAX_BUFFER_LEN_SEND - #TWO_BYTE_LEN_INFO THEN
                                CASE #statUnsubscribeTopicEncodeState OF
                                  #FIRST_ENCODING:  // Statement section case 1
                                    //ADD len info into paket
                                    
                                    #tempWordForSliceAddress := UINT_TO_WORD(#statUnsubscribeTopicLenUtf8Encoded);
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B1; //MSB
                                    #statSendBufferPos += 1;
                                    #statSendBuffer[#statSendBufferPos] := #tempWordForSliceAddress.%B0; // LSB
                                    #statSendBufferPos += 1;
                                    
                                    FOR #tempLoopCounter := #statUnsubscribeTopicPos TO LEN(#mqttTopic) DO
                                      "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                            convertedUtf8 => #tempConvertedUtf8,
                                                            bytesUsed     => #tempBytesUsedUtf8,
                                                            error         => #tempErrorConvertUtf8,
                                                            status        => #tempStatusConvertUtf8);
                                      
                                      IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                                        #statUnsubscribeTopicPos += 1;
                                        CASE #tempBytesUsedUtf8 OF
                                          #UTF_1_BYTE_USED:  // Statement section case 1
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                          #UTF_2_BYTE_USED:
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                          #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                            #statSendBufferPos += 1;
                                          ELSE  // Statement section ELSE
                                            ;
                                        END_CASE;
                                      ELSE
                                        //When buffer full
                                        #statUnsubscribeTopicEncodeState := #SUBSEQUENT_ENCODING;
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    IF #statUnsubscribeTopicPos >= LEN(#mqttTopic) THEN
                                      #statUnsubscribeTopicEncodeState := #ENCODE_DONE;
                                    END_IF;
                                    
                                  #SUBSEQUENT_ENCODING:  // Statement section case 2 to 4
                                    FOR #tempLoopCounter := #statUnsubscribeTopicPos TO LEN(#mqttTopic) DO
                                      
                                      "LMQTT_ConvertToUtf8"(character     := #mqttTopic[#tempLoopCounter],
                                                            convertedUtf8 => #tempConvertedUtf8,
                                                            bytesUsed     => #tempBytesUsedUtf8,
                                                            error         => #tempErrorConvertUtf8,
                                                            status        => #tempStatusConvertUtf8);
                                      IF #statSendBufferPos + #tempBytesUsedUtf8 <= #MAX_BUFFER_LEN_SEND THEN
                                        #statUnsubscribeTopicPos += 1;
                                        CASE #tempBytesUsedUtf8 OF
                                          #UTF_1_BYTE_USED:  // Statement section case 1
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                          #UTF_2_BYTE_USED:
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                          #UTF_3_BYTE_USED:  // Statement section case 2 to 4
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B0;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B1;
                                            #statSendBufferPos += 1;
                                            #statSendBuffer[#statSendBufferPos] := #tempConvertedUtf8.%B2;
                                            #statSendBufferPos += 1;
                                          ELSE  // Statement section ELSE
                                            ;
                                        END_CASE;
                                      ELSE
                                        //When buffer full
                                        EXIT;
                                      END_IF;
                                    END_FOR;
                                    IF #statUnsubscribeTopicPos >= LEN(#mqttTopic) THEN
                                      #statUnsubscribeTopicEncodeState := #ENCODE_DONE;
                                    END_IF;
                                  ELSE  // Skip when Done
                                    ;
                                END_CASE;
                              END_IF;
                              
                              //set Sendlen for TSendC Block
                              #statTsendcLen := #statSendBufferPos; // Buffer pos equals amount of elements in send array
                              //reset buffer pos
                              #statSendBufferPos := 0;
                              //enable Send Req
                              #statTsendcReq := TRUE;
                              //Set Watchdog
                              #statEnableTimerCommandWatchdog := TRUE;
                              //wait for send to be done
                              #statMqttCommandState := #MQTT_COMMAND_STATE_SEND_UNSUBSCRIBE;
                            END_IF;
                          END_IF;
                        END_REGION UNSUBSCRIBE_FROM_TOPIC
                        
                      #MQTT_COMMAND_STATE_SEND_UNSUBSCRIBE:
                        REGION SEND_UNSUBSCRIBE_WAIT_FOR_RESPONSE
                          //check tsend status
                          IF NOT #tempTsendcBusy AND #tempTsendcStatus = #TSENDC_JOB_DONE THEN
                            IF (#statUnsubscribeTopicEncodeState = #ENCODE_DONE) THEN
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                            ELSE
                              // More to Encode and send
                              #statEnableTimerCommandWatchdog := FALSE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_BUILD_UNSUBSCRIBE;
                            END_IF;
                          END_IF;
                          // Wait for timeout
                          IF #instTimerCommandWatchdog.Q THEN
                            #statEnableTimerCommandWatchdog := FALSE;
                            #statStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Set correct status that identifies error clearly
                            #statSubfunctionStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Status or return value of called FBs, FCs and system blocks
                            #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                            #statErrorAutoCleared := TRUE;
                            #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_IF;
                          //Check Unsubscribe ACK paket
                          CASE #tempMqttUnSubAckRcv OF
                            #NO_RESPONSE:  // Statement section case 1
                              ;
                            #RESPONSE_GOOD:  // Statement section case 2 to 4
                              //disable watchdog
                              #statEnableTimerCommandWatchdog := FALSE;
                              //Encoding done all sent
                              #statPaketHeaderEncodeDone := FALSE;
                              // Job done
                              #statDone := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              // Set Status back to connected
                              #statStatus := #STATUS_JOB_EXECUTED;
                            #RESPONSE_PAKET_ID_INVALID:
                              #statStatus := #ERR_MQTT_PAKET_ID_INVALID; // Set correct status that identifies error clearly
                              #statSubfunctionStatus := #ERR_MQTT_PAKET_ID_INVALID; // Status or return value of called FBs, FCs and system blocks
                              #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                              #statErrorAutoCleared := TRUE;
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_CASE;
                        END_REGION SEND_UNSUBSCRIBE_WAIT_FOR_RESPONSE
                        
                      #MQTT_COMMAND_STATE_SEND_PING:
                        REGION SEND_PING
                          //Set Status
                          #statStatus := #STATUS_MQTT_PING;
                          IF #tempTsendcBusy = FALSE // when tsendC is ready
                            AND #tempTsendcDone = FALSE // tsendC did not finish in this cycle
                            AND #statTsendcReq = FALSE // TsendC request was not already requested by pub ack msg
                          THEN
                            //Init
                            #statSendBufferPos := 0;
                            #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_PING;
                            #statSendBufferPos += 1;
                            //Remaining Lenght (must be 0)
                            #statSendBuffer[#statSendBufferPos] := 0;
                            #statSendBufferPos += 1;
                            #statTsendcLen := #statSendBufferPos;
                            //Start send request
                            #statTsendcReq := TRUE;
                            //Start watchdoc
                            #statEnableTimerCommandWatchdog := true;
                            //Next state
                            #statMqttCommandState := #MQTT_COMMAND_STATE_PING_RESP;
                          END_IF;
                        END_REGION MQTT_COMMAND_SEND_PING
                        
                      #MQTT_COMMAND_STATE_PING_RESP:
                        REGION WAIT_FOR_PING_RESP
                          //Check, if Edge of Publish comes while ping
                          IF #tempCommandInput > 0 AND NOT #statCommandInputOld THEN
                            #statCommandInputBackup := #tempCommandInput;
                            #statCommandInputOld := true;
                          END_IF;
                          //check watchdog status
                          IF #instTimerCommandWatchdog.Q THEN
                            #statEnableTimerCommandWatchdog := FALSE;
                            #statStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Set correct status that identifies error clearly
                            #statSubfunctionStatus := #ERR_MQTT_COMMAND_SEND_TIMEOUT; // Status or return value of called FBs, FCs and system blocks
                            #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                            #statErrorAutoCleared := TRUE;
                            #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                          END_IF;
                          //Check PingRsp paket
                          CASE #tempMqttPingRspRcv OF
                            #NO_RESPONSE:  // Statement section case 1
                              ;
                            #RESPONSE_GOOD:
                              //disable watchdog
                              #statEnableTimerCommandWatchdog := FALSE;
                              //Go to no processing
                              #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
                              //set Status
                              #statStatus := #STATUS_MQTT_CONNECTED;
                              IF #statCommandInputBackup <> 0 THEN
                                #statMqttCommandState := BYTE_TO_DINT(#statCommandInputBackup);
                                #statCommandInputBackup := 0;
                                #statCommandInputOld := false;
                              END_IF;
                          END_CASE;
                        END_REGION MQTT_COMMAND_PING_RESP
                      ELSE  // Statement section ELSE
                        REGION ERROR_MULTIPLE_INPUT
                          #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING; // reset back to idle
                          #statStatus := #ERR_MQTT_COMMAND_MULTIPLE_INPUT; // Set correct status that identifies error clearly
                          #statSubfunctionStatus := #ERR_MQTT_COMMAND_MULTIPLE_INPUT; // Status or return value of called FBs, FCs and system blocks
                          #statFBErrorState := #statFBState; // Set error state number for diagnostic 
                          #statErrorAutoCleared := TRUE;
                        END_REGION ERROR_MULTIPLE_INPUT 
                    END_CASE;
                  END_REGION
                  
                  REGION CHECK_PING_TIMER
                    //If no job is running check if keepalive experied
                    IF #statMqttCommandState = #MQTT_COMMAND_STATE_NO_PROCESSING
                      AND #instMqttKeepAliveTimer.Q THEN
                      //reset the timer
                      RESET_TIMER(#instMqttKeepAliveTimer);
                      //go to ping state
                      #statMqttCommandState := #MQTT_COMMAND_STATE_SEND_PING;
                    END_IF;
                  END_REGION CHECK_PING_TIMER
                  
                  //Edge detection "publish / subscribe/unsubscribe" input
                  #statPublishOld := #tempPublish;
                  #statSubscribeOld := #tempSubscribe;
                  #statUnsubscribeOld := #tempUnsubscribe;
                END_REGION CONNECTED
                
              ELSE   // Undefined state in state machine reached
                #statStatus := #ERR_UNDEFINED_STATE;
                #statErrorUserCleared := TRUE;
            END_CASE;
            
          END_REGION MQTT_STATE_MACHINE
        END_IF;
      END_REGION FB_OPERATING_MONITOR_TCP
      
    #FB_STATE_TCP_RECONNECTING:
      REGION FB_STATE_TCP_RECONNECTING
        IF #tempTsendcStatus = #TSENDC_EST_OK THEN
          #statErrorAutoCleared := FALSE;
          // Update edge detection
          #statPublishOld := #tempPublish;
          #statSubscribeOld := #tempSubscribe;
          #statUnsubscribeOld := #tempUnsubscribe;
          //Monitor Connection
          #statFBState := #FB_STATE_OPERATING_MONITOR_TCP;
          // Begin MQTT Connection
          #statMqttConnectState := #MQTT_CONNECT_STATE_BUILD_PAKET;
        END_IF;
      END_REGION FB_STATE_TCP_RECONNECTING
    #FB_STATE_DISABLING: // Disabling active
      REGION DISABLING FB
        //  Disabling, e.g. closing connections, etc.
        // When disabling is complete the bit #statDisablingCompleted must be set
        // When MQTT is connected, send disconnect
        IF #statMqttConnectState = #MQTT_CONNECT_STATE_CONNECTED THEN
          IF #statTsendcReq = TRUE THEN
            //Interrupt any existing send jobs
            #statTsendcReq := FALSE;
          ELSE
            // INIT
            #statSendBufferPos := 0;
            //Build fixed Header
            //Message Type
            #statSendBuffer[#statSendBufferPos] := #MQTT_MSG_TYPE_DISCONNECT;
            #statSendBufferPos += 1;
            //Remaining Length (must be O)
            #statSendBuffer[#statSendBufferPos] := #REMAINIG_LEN_0;
            #statSendBufferPos += 1;
            //send request
            #statTsendcLen := #statSendBufferPos;
            #statTsendcReq := TRUE;
            #statMqttConnectState := #MQTT_CONNECT_STATE_DISCONNECTED;
          END_IF;
        ELSE
          //Disable TCP Connection
          #statTsendcReq := FALSE;
          #statTsendcEnable := FALSE;
          #statEnableTimerCommandWatchdog := TRUE;
        END_IF;
        // When TCP connection is closed
        IF #tempTsendcStatus = #TSENDC_DISCONNECTED THEN
          #statEnableTimerCommandWatchdog := FALSE;
          #statDisablingCompleted := TRUE;
        ELSIF #instTimerCommandWatchdog.Q THEN
          #statEnableTimerCommandWatchdog := FALSE;
          #statDisablingCompleted := TRUE;
        END_IF;
      END_REGION DISABLING FB
    ELSE // Undefined state in state machine reached
      #statStatus := #ERR_UNDEFINED_STATE;
      #statErrorUserCleared := TRUE;
  END_CASE;
END_REGION STATE_MACHINE

REGION OUTPUTS
  // Write outputs
  IF (#statDisablingCompleted = TRUE) THEN
    // Reset outputs if disabling completed
    #statValid := FALSE;
    #statBusy := FALSE;
    #statError := FALSE;
    #statDone := FALSE;
    #statErrorUserCleared := FALSE;
    #statErrorAutoCleared := FALSE;
    #statStatus := #STATUS_NO_CALL;
    // Reset application specific outputs
    #statRcvMsgStatus := #MSG_DECODE_STATUS_NO_NEW_MSG;
    #statRcvMsgDataLen := 0;
    
  ELSIF (#statErrorUserCleared = TRUE) AND (#statError = FALSE) THEN
    // Error can only be cleared by user; rising edge at enable input is needed to continue 
    #statValid := FALSE;
    #statBusy := FALSE;
    #statDone := FALSE;
    #statError := TRUE;
    // Write diagnostics
    #diagnostics.status := #statStatus;
    #diagnostics.subfunctionStatus := #statSubfunctionStatus;
    #diagnostics.stateNumber := #statFBErrorState;
    // execution aborted --> set state no processing
    #statTsendcEnable := FALSE; // Terminate Connection, no reason keep it up.
    #statFBState := #FB_STATE_NO_PROCESSING;
    #statMqttConnectState := #MQTT_CONNECT_STATE_NO_PROCESSING;
    #statMqttCommandState := #MQTT_COMMAND_STATE_NO_PROCESSING;
    #statRcvMsgDecodeState := #MSG_DECODE_STATE_NO_PROCESSING;
    
  ELSIF (#statErrorAutoCleared = TRUE) AND (#statError = FALSE) THEN
    // Error can be reset by FB automatically
    #statValid := FALSE;
    #statBusy := TRUE;
    #statError := TRUE;
    #statDone := FALSE;
    
    // Write diagnostics
    #diagnostics.status := #statStatus;
    #diagnostics.subfunctionStatus := #statSubfunctionStatus;
    #diagnostics.stateNumber := #statFBErrorState;
    // Handling of autocleared error
    CASE #statStatus OF
        //Just signal error and reset autocleared error afterwards.
      #ERR_MQTT_PAKET_ID_INVALID, #ERR_MQTT_SUBACK_FAILURE, #ERR_MQTT_CONNECT_TIMEOUT,
      #ERR_MQTT_COMMAND_SEND_TIMEOUT, #ERR_MQTT_COMMAND_MULTIPLE_INPUT, #ERR_CNT_EXCEEDS_ARRAY_DIMENSION,
      #ERR_MQTT_COMMAND_PUBLISH_TOPIC_INVALID, #ERR_QOS_INVALID, #ERR_MQTT_COMMAND_SUBSCRIBE_TOPIC_INVALID:
        #statErrorAutoCleared := FALSE;
        
      ELSE  // Statement section ELSE
        ;
    END_CASE;
    
  ELSIF (#statErrorAutoCleared = FALSE) AND (#statErrorUserCleared = FALSE) AND (#statError = TRUE) THEN
    // If autocleared error is acknowledged
    #statValid := TRUE;
    #statBusy := TRUE;
    #statError := FALSE;
    #statDone := FALSE;
    
    //   this line  more detailed status information is used instead of "#STATUS_SUBSEQUENT_CALL"
    CASE #statStatus OF
      #ERR_TCP_RECONNECTING, #ERR_MQTT_CONNECT_TIMEOUT:  // Reconnecting ok, start Mqtt reconnnect
        //set status
        #statStatus := #STATUS_MQTT_CONNECTING;
        //in the following status codes status stays connected. 
      #ERR_MQTT_PAKET_ID_INVALID, #ERR_MQTT_SUBACK_FAILURE, #ERR_MQTT_COMMAND_SEND_TIMEOUT,
      #ERR_MQTT_COMMAND_MULTIPLE_INPUT, #ERR_CNT_EXCEEDS_ARRAY_DIMENSION, #ERR_MQTT_COMMAND_PUBLISH_TOPIC_INVALID,
      #ERR_QOS_INVALID, #ERR_MQTT_COMMAND_SUBSCRIBE_TOPIC_INVALID:
        #statStatus := #STATUS_MQTT_CONNECTED;
      ELSE  // Statement section ELSE
        ;
    END_CASE;
  END_IF;
  
  // Write static values to outputs
  #valid := #statValid;
  #busy := #statBusy;
  #error := #statError;
  #status := #statStatus;
  //block sets ENO automatically:
  //ENO := TRUE;
  //Write application specific static values to outputs
  #done := #statDone;
  #receivedMsgStatus := #statRcvMsgStatus;
  #receivedMsgDataLen := #statRcvMsgDataLen;
END_REGION OUTPUTS
